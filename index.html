<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Lonely920" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Lonely920">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lonely920">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lonely920">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Lonely920 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lonely920</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Sun</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/ios面试题集/" itemprop="url">
                  ios面试题集
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T15:22:55+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、OC基本概念"><a href="#一、OC基本概念" class="headerlink" title="一、OC基本概念"></a>一、OC基本概念</h1><h3 id="1-static-关键字的作用"><a href="#1-static-关键字的作用" class="headerlink" title="1.static 关键字的作用"></a>1.static 关键字的作用</h3><p>（1）函数体内 <strong>static</strong> 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次， 因此其值在下次调用时仍维持上次的值；<br>（2）在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；<br>（3）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； </p>
<h3 id="2-关键字const有什么含义"><a href="#2-关键字const有什么含义" class="headerlink" title="2.关键字const有什么含义"></a>2.关键字const有什么含义</h3><p>const意味着“只读”<br>本质：const在谁后面谁就不可修改，const在最前面则将其后移一位即可,二者等效</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，指向的整型数是不可修改的，但指针可以，此最常见于函数的参数，当你只引用传进来指针所指向的值时应该加上const修饰符，程序中修改编译就不通过，可以减少程序的bug）。<br>第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。<br>const关键字至少有下列n个作用：<br>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> classA operator*(<span class="keyword">const</span> classA&amp; a1,<span class="keyword">const</span> classA&amp; a2); </div><div class="line">　　operator*的返回结果必须是一个<span class="keyword">const</span>对象。如果不是，这样的变态代码也不会编译出错：</div><div class="line">classA a, b, c;</div><div class="line">(a * b) = c; <span class="comment">// 对a*b的结果赋值 </span></div><div class="line">操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。</div></pre></td></tr></table></figure>
<h3 id="3-OC中有哪些数据存储方式-各有什么区别"><a href="#3-OC中有哪些数据存储方式-各有什么区别" class="headerlink" title="3.OC中有哪些数据存储方式,各有什么区别"></a>3.OC中有哪些数据存储方式,各有什么区别</h3><p><strong>四种存储方式: </strong><br>1.NSUserDefaults,用于存储配置信息<br>2.SQLite,用于存储查询需求较多的数据<br>3.CoreData,用于规划应用中的对象(MagicalRecord)<br>4.使用基本对象类型定制的个性化缓存方案.(归档)<br>NSUserDefaults:对象中储存了系统中用户的配置信息,开发者可以通过这个实例对象对这些已有的信息进行修改,也 可以按照自己的需求创建新的配置项。<br>SQLite擅长处理的数据类型其实与NSUserDefaults差不多,也是基础类型的小数据,只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据,使用SQL DML来管理数据。一般来说应用中的格式化的文本类数据可以存放在数据库 中,尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。<br>CoreData是一个管理方案,它的持久化可以通过SQLite、XML或二进制文件储存。它可以把整个应用中的对象建模并进 行自动化的管理。从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存,而是根据运行时状 态,把被调用到的对象实例载入内存。框架会自动控制这个过程,从而达到控制内存消耗,避免浪费。 无论从设计原理还是使用方法上看,CoreData都比较复杂。因此,如果仅仅是考虑缓存数据这个需求,CoreData绝对不 是一个优选方案。CoreData的使用场景在于:整个应用使用CoreData规划,把应用内的数据通过CoreData建模,完全 基于CoreData架构应用。<br>使用基本对象类型定制的个性化缓存方案:从需求出发分析缓存数据有哪些要求:按Key查找,快速读取,写入不影响正常 操作,不浪费内存,支持归档。这些都是基本需求,那么再进一步或许还需要固定缓存项数量,支持队列缓存,缓存过期等。</p>
<h3 id="4-ios平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗"><a href="#4-ios平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗" class="headerlink" title="4.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?"></a>4.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?</h3><p><strong>iOS中可以有四种持久化数据的方式: 属性列表、对象归档、SQLite3和Core Data</strong><br>coredata可以使你以图形界面的方式快速的定义app的数据模型,同时在你的代码中容易获取到它。coredata提供了基础结构去处 理常用的功能,例如保存,恢复,撤销和重做,允许你在app中继续创建新的任务。在使用coredata的时候,你不用安装额外的数据 库系统,因为coredata使用内置的sqlite数据库。coredata将你app的模型层放入到一组定义在内存中的数据对象。coredata会 追踪这些对象的改变,同时可以根据需要做相应的改变,例如用户执行撤销命令。当coredata在对你app数据的改变进行保存的时 候,core data会把这些数据归档,并永久性保存。<br>mac os x中sqlite库,它是一个轻量级功能强大的关系数据引擎,也很容易嵌入到应用程序。可以在多个平台使用,sqlite是一个轻 量级的嵌入式sql数据库编程。与coredata框架不同的是,sqlite是使用程序式的,sql的主要的API来直接操作数据表。<br>Core Data不是一个关系型数据库,也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型, 但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系。</p>
<h3 id="5-堆栈的区别（Heap是堆，stack是栈）"><a href="#5-堆栈的区别（Heap是堆，stack是栈）" class="headerlink" title="5.堆栈的区别（Heap是堆，stack是栈）"></a>5.堆栈的区别（Heap是堆，stack是栈）</h3><p>(1)管理方式:对于栈来讲,是由编译器自动管理,无需我们手工控制;对于堆来说,释放工作由程序员控制,容易产生 memory leak。<br>(2)申请大小:能从栈获得的空间较小,堆是向高地址扩展的数据结构,是不连续的内存区域。堆的大小受限于计算机系统中 有效的虚拟内存。由此可见,堆获得的空间比较灵活,也比较大。<br>(3)碎片问题:对于堆来讲,频繁的new/delete势必会造成内存空间的不连续,从而造成大量的碎片,使程序效率降低。 对于栈来讲,则不会存在这个问题,因为栈是先进后出的队列,他们是如此的一一对应,以至于永远都不可能有一个内存块 从栈中间弹出<br>(4)分配方式:堆都是动态分配的,没有静态分配的堆。栈有2种分配方式:静态分配和动态分配。静态分配是编译器完成 的,比如局部变量的分配。动态分配由 alloca函数进行分配,但是栈的动态分配和堆是不同的,他的动态分配是由编译器 进行释放,无需我们手工实现。<br>(5)分配效率:栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈 都有专门的指令执行,这就决定了栈的效率比较高。堆则是C/C++函数库提供的,它的机制是很复杂的。  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。Stack空间有限，Heap是很大的自由存储区  </div><div class="line">C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。  </div><div class="line">程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行</div></pre></td></tr></table></figure>
<h3 id="6-面向对象的三大特征-并作简单的介绍"><a href="#6-面向对象的三大特征-并作简单的介绍" class="headerlink" title="6.面向对象的三大特征,并作简单的介绍"></a>6.面向对象的三大特征,并作简单的介绍</h3><p><strong>面向对象的三个基本特征是:封装、继承、多态。</strong><br>封装是面向对象的特征之一,是对象和类概念的主要特性。 封装,也就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏。隐藏对象的属性和实现细节,仅对外公开接口,提高代 码安全性,封装程度越高,独立性越强,使用越方便。<br>继承是指这样一种能力:它可以使用现有类的所有功能,并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过 继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”<br>多态性:允许你将父对象设置成为和一个或更多的他的子对象相等的技术,赋值之后,父对象就可以根据当前赋值给它的子 对象的特性以不同的方式运作。简单的说,就是一句话:<strong>允许将子类类型的指针赋值给父类类型的指针</strong></p>
<h3 id="7-我们说的obc是动态运行时语言是什么意思"><a href="#7-我们说的obc是动态运行时语言是什么意思" class="headerlink" title="7.我们说的obc是动态运行时语言是什么意思"></a>7.我们说的obc是动态运行时语言是什么意思</h3><p><strong>多态</strong>。主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实涉及到两个概念,运行时和多态。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。多态:不同对象以自己的方式响应 相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;那人类属于生物,猪也属于生物,都 继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础</p>
<h3 id="8-readwrite-readonly-assign-retain-copy-nonatomic-、strong、weak属性的作用-并区别strong-强引用-、-weak-弱引用-什么情况使用copy-assign-和retain"><a href="#8-readwrite-readonly-assign-retain-copy-nonatomic-、strong、weak属性的作用-并区别strong-强引用-、-weak-弱引用-什么情况使用copy-assign-和retain" class="headerlink" title="8.readwrite,readonly,assign,retain,copy,nonatomic 、strong、weak属性的作用?并区别strong(强引用)、 weak(弱引用)?什么情况使用copy,assign,和retain?"></a>8.readwrite,readonly,assign,retain,copy,nonatomic 、strong、weak属性的作用?并区别strong(强引用)、 weak(弱引用)?什么情况使用copy,assign,和retain?</h3><p>readwrite 是可读可写特性;需要生成getter方法和setter方法时<br>readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变<br>assign 是赋值特性,setter方法将传入参数赋值给实例变量;仅设置变量时;<br>retain 表示持有特性,setter方法将传入参数先保留,再赋值,传入参数的retaincount会+1;<br>copy 表示赋值特性,setter方法将传入对象复制一份;需要完全一份新的变量时。<br>nonatomic 非原子操作,决定编译器生成的setter getter是否是原子操作,atomic表示多线程安全,一般使用 nonatomic<br>assign用于简单数据类型,如NSInteger,double,bool。<br>retain 和copy用户对象,copy用于当 a指向一个对象,b也想指向同样的对象的时候,如果用assign,a如果释放,再 调用b会crash,如果用copy 的方式,a和b各自有自己的内存,就可以解决这个问题。retain 会使计数器加1,也可以解 决assign的问题。另外:atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。 在多线程环境 下,原子操作是必要的,否则有可能引起错误的结果。</p>
<h3 id="9-分别描述内存管理要点、autorelease、release、NSAutoreleasePool-并说明autorelease是什-么时候被release的-简述什么时候由你负责释放对象-什么时候不由你释放-NSAutoreleasePool-release-和-NSAutoreleasePool-drain-有什么区别"><a href="#9-分别描述内存管理要点、autorelease、release、NSAutoreleasePool-并说明autorelease是什-么时候被release的-简述什么时候由你负责释放对象-什么时候不由你释放-NSAutoreleasePool-release-和-NSAutoreleasePool-drain-有什么区别" class="headerlink" title="9.分别描述内存管理要点、autorelease、release、NSAutoreleasePool?并说明autorelease是什 么时候被release的?简述什么时候由你负责释放对象,什么时候不由你释放?[NSAutoreleasePool release]和[NSAutoreleasePool drain]有什么区别?"></a>9.分别描述内存管理要点、autorelease、release、NSAutoreleasePool?并说明autorelease是什 么时候被release的?简述什么时候由你负责释放对象,什么时候不由你释放?[NSAutoreleasePool release]和[NSAutoreleasePool drain]有什么区别?</h3><p><strong>内存管理要点:</strong><br>内存管理:管理堆区内存的分配和释放；<br>Objective-C 使用引用计数机制(retainCount)来管理内存。内存每被引用一次,该内存的引用计数+1,每被释放一次引 用计数-1。当引用计数 = 0 的时候,调用该对象的 dealloc 方法,来彻底从内存中删除该对象。<br>alloc,allocWithZone,new(带初始化)时:该对象引用计数 +1;<br>retain:手动为该对象引用计数 +1;<br>copy:对象引用计数 +1;<br>mutableCopy:生成一个新对象,新对象引用计数为 1;<br>release:手动为该对象引用计数 -1; autorelease:把该对象放入自动释放池,当自动释放池释放时,其内的对象引用计数 -1。<br><strong>NSAutoreleasePool:</strong><br>NSAutoreleasePool是通过接收对象向它发送的autorelease消息,记录该对象的release消息,当自动释放池被销毁 时,会自动向池中的对象发送release消息。<br>autorelease 是在自动释放池被销毁,向池中的对象发送release<br>只能释放自己拥有的对象,<br><strong>区别是</strong>:在引用计数环境下(在不使用ARC情况下),两者基本一样,在GC环境下,release 是一个no-op(无效操 作),所以无论是不是gc都使用drain</p>
<h3 id="10-浅复制和深复制的区别"><a href="#10-浅复制和深复制的区别" class="headerlink" title="10.浅复制和深复制的区别"></a>10.浅复制和深复制的区别</h3><p>浅层复制(copy):只复制指向对象的指针,而不复制引用对象本身。//通过对象的指针来访问这个对象—-只复制地址<br>深层复制(mutableCopy):复制引用对象本身—再创建一个对象 意思就是有个A对象,复制一份后得到A_copy对象后,对于浅复制来说,A和A_copy指向的是同一个内存资源,复制的 只不过是是一个指针,对象本身资源 还是只有一份,那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改,这其实违背了我们复制拷贝的一 个思想。深复制就好理解了,内存中存在了<br>两份独立对象本身。//当修改A时,A copy不变</p>
<h3 id="11-什么是安全释放"><a href="#11-什么是安全释放" class="headerlink" title="11.什么是安全释放"></a>11.什么是安全释放</h3><p>MRC中，要释放一个对象<br>[obj release]; 释放对象之后，不会修改对象的指针地址，后续如果给 obj 发送消息，就会出现也指针错误<br>[obj nil]; 对象地址已经指向NULL，这个时候再发任何消息也不会报错。<br>僵尸对象：已经被释放的对象<br>野指针：指向僵尸对象的指针<br>空指针：nil，给空指针发送任何消息都不会报错</p>
<h3 id="12-NULL与nil-NSNULL"><a href="#12-NULL与nil-NSNULL" class="headerlink" title="12.NULL与nil/NSNULL"></a>12.NULL与nil/NSNULL</h3><p>nil：是地址指向NULL的空对象，在OC/C++中，给nil对象发送任何消息，都不会报错<br>NULL：是空地址，本身就是0,就是一个整数，不能给NULL发送消息<br>NSNULL：[NSNULL null]; 用处：就是向NSDictionary/NSArray中添加空对象使用的，只要用在通过运行时机制或KVC动态给对象属性设置数值时使用</p>
<h3 id="13-obj-c的优缺点"><a href="#13-obj-c的优缺点" class="headerlink" title="13.obj-c的优缺点"></a>13.obj-c的优缺点</h3><p><strong>objc优点：</strong><br>  1) Cateogies<br>  2) Posing<br>  3) 动态识别<br>  4) Objective-C 与 C++ 可混合编程<br><strong>缺点:</strong><br>  1) 不支持命名空间<br>  2)  不支持运算符重载<br>  3）不支持多重继承<br>  4）使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。</p>
<h3 id="14-什么时候用delegate，什么时候用Notification？"><a href="#14-什么时候用delegate，什么时候用Notification？" class="headerlink" title="14.什么时候用delegate，什么时候用Notification？"></a>14.什么时候用delegate，什么时候用Notification？</h3><p>答：delegate针对one-to-one关系，并且reciever可以返回值 给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到 reciever的某个功能反馈值，notification用于通知多个object某个事件。 </p>
<h3 id="15-什么是KVC和KVO"><a href="#15-什么是KVC和KVO" class="headerlink" title="15.什么是KVC和KVO"></a>15.什么是KVC和KVO</h3><p>KVC:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。<br>KVC(Key-Value-Coding)内部的实现：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。<br>KVO:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码<br>KVO（Key-Value- Observing）：当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以 isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名<br>的类名<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"highlighted"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>];   </div><div class="line"><span class="meta">#pragma mark KVO   </span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">	<span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"highlighted"</span>]) &#123;</div><div class="line">	[<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>KVC:破坏类的封装性可以直接访问属性</strong></p>
<h3 id="16-KVO的底层实现原理（runTime运行时）"><a href="#16-KVO的底层实现原理（runTime运行时）" class="headerlink" title="16.KVO的底层实现原理（runTime运行时）"></a>16.KVO的底层实现原理（runTime运行时）</h3><p>1.（添加监听者时）保存所有参数（监听者、枚举、携带参数、路径）<br>2.创建子类NSKVONotifying-（类名），并重写set方法<br>3.set方法，监听者底层调用自己的observeValueForKeyPath</p>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>Notification 是观察者模式的实现,KVO是观察者模式的OB-C底层实现。<br>NOtification 通过 Notifydcation addobserver 和 remove observer 工作。<br>KVO是键值监听,键值观察机制,提供了观察某一属性变化的方法<br>KVC是键值编码,是一种间接访问对象的属性,使用字符串来标示属性(例如:setValue:forKey:)<br>Delegate:把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理,代替它来打理要做的事。反映到程序中,首先要明确一个对象的委托方是哪个对象,委托所做的内容是什么。</p>
<h3 id="17-类别的作用？继承和类别在实现中有何区别？"><a href="#17-类别的作用？继承和类别在实现中有何区别？" class="headerlink" title="17.类别的作用？继承和类别在实现中有何区别？"></a>17.类别的作用？继承和类别在实现中有何区别？</h3><p>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。<br>类别主要有3个作用：<br>(1)将类的实现分散到多个不同文件或多个不同框架中。<br>(2)创建对私有方法的前向引用。<br>(3)向对象添加非正式协议。<br>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
<h3 id="18-类别和类扩展的区别"><a href="#18-类别和类扩展的区别" class="headerlink" title="18.类别和类扩展的区别"></a>18.类别和类扩展的区别</h3><p>category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。分类的小括号中必须有名字，分类只能扩充方法，不能扩充属性和成员变量。(Category只能为对象添加方法,却不能添加成员变量的原因:如果可以添加成员变量,添加的成员变量没有办法初始 化—-这是语言规则)<br>extensions可以认为是一个私有的Category<br><strong>分类中能不能添加属性呢？</strong><br>如果通过@Property给分类新增属性，那么@property只会生成该属性的getter和setter方法的声明，而不会生成属性和实现方法。</p>
<h3 id="19-为什么不能包含分类的-m文件"><a href="#19-为什么不能包含分类的-m文件" class="headerlink" title="19.为什么不能包含分类的.m文件"></a>19.为什么不能包含分类的.m文件</h3><p>因为这样会重复包含另一个类的实现文件</p>
<h3 id="20-方法和选择器有何不同"><a href="#20-方法和选择器有何不同" class="headerlink" title="20.方法和选择器有何不同"></a>20.方法和选择器有何不同</h3><p>selector是一个方法的名字，method是一个组合体，包含了名字和实现</p>
<h3 id="21-OC有多继承吗-没有的话可以用什么方法替—多继承即一个子类可以有多个父类-它继承了多个父类的特性。"><a href="#21-OC有多继承吗-没有的话可以用什么方法替—多继承即一个子类可以有多个父类-它继承了多个父类的特性。" class="headerlink" title="21.OC有多继承吗?没有的话可以用什么方法替—多继承即一个子类可以有多个父类,它继承了多个父类的特性。"></a>21.OC有多继承吗?没有的话可以用什么方法替—多继承即一个子类可以有多个父类,它继承了多个父类的特性。</h3><p>Object-c的类没有多继承,只支持单继承,如果要实现多继承的话,可以通过类别和协议的方式来实现,OC类似于多继承,是在用protocol委托代理来实现的;可以实现多个接口,通过实现多个接口可以完成C++的多重继承;Category是类别,一 般情况用分类好,用Category去重写类的方法,仅对本Category有效,不会影响到其他类与原有类的关系。</p>
<h3 id="22-Objective-C有私有方法么-私有变量呢-如果没有的话-有没有什么代替的方法"><a href="#22-Objective-C有私有方法么-私有变量呢-如果没有的话-有没有什么代替的方法" class="headerlink" title="22.Objective-C有私有方法么?私有变量呢?如果没有的话,有没有什么代替的方法?"></a>22.Objective-C有私有方法么?私有变量呢?如果没有的话,有没有什么代替的方法?</h3><p>objective-c类里面的方法只有两种, 静态方法和实例方法.但是可以通过把方法的声明和定义都放在.m文件中来实现一个表面上的私有方法。有私有变量,可以通过@private来修饰,或者把声明放到.m文件中。在Objective‐C中,所有实例变 量默认都是私有的,所有实例方法默认都是公有的</p>
<h3 id="23-import、-include和-class有什么区别"><a href="#23-import、-include和-class有什么区别" class="headerlink" title="23.#import、#include和@class有什么区别"></a>23.#import、#include和@class有什么区别</h3><p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到,它只是声明了一个类名,关于这个类的内部实现都没 有告诉编译器,在m文件中还是需要使用#import。<br>而#import比起#include的好处就是不会引起交叉编译。</p>
<h3 id="24-谈谈你对MVC的理解-为什么要用MVC-在Cocoa中MVC是怎么实现的-你还熟悉其他的OC设计模式或别-的设计模式吗"><a href="#24-谈谈你对MVC的理解-为什么要用MVC-在Cocoa中MVC是怎么实现的-你还熟悉其他的OC设计模式或别-的设计模式吗" class="headerlink" title="24.谈谈你对MVC的理解?为什么要用MVC?在Cocoa中MVC是怎么实现的?你还熟悉其他的OC设计模式或别 的设计模式吗?"></a>24.谈谈你对MVC的理解?为什么要用MVC?在Cocoa中MVC是怎么实现的?你还熟悉其他的OC设计模式或别 的设计模式吗?</h3><p>MVC就是Model-View-Controller的缩写,M指的是业务模型,V指的是用户页面,C指的是控制器。MVC是架构模式,是讲M和 V的代码分离,从而使同那个一个程序可以使用不同的表现形式。<br>M:表示数据和业务规则,V是用户看到的并与之交互的页面,C是接受用户的输入并调用M和V取完成用户需求的 单例,代理,观察者,工厂模式等<br>单例模式:说白了就是一个类不通过alloc方式创建对象,而是用一个静态方法返回这个类的对象。系统只需要拥有一个的 全局对象,这样有利于我们协调系统整体的行为;<br>代理模式:代理模式给某一个对象提供一个代理对象,并由代理对象控制对源对象的引用.比如一个工厂生产了产品,并不想 直接卖给用户,而是搞了很多代理商,用户可以直接找代理商买东西,代理商从工厂进货.常见的如QQ的自动回复就属于代 理拦截,代理模式在iphone中得到广泛应用.<br>观察者模式: 当一个物体发生变化时,会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的 对象给这个物体,当这个物体的发生改变,就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的;</p>
<h3 id="25-c和obj-c如何混用"><a href="#25-c和obj-c如何混用" class="headerlink" title="25.c和obj-c如何混用?"></a>25.c和obj-c如何混用?</h3><p>1)obj-c的编译器处理后缀为m的文件时,可以识别obj-c和c的代码,处理mm文件可以识别obj-c,c,c++代码,但cpp文件必须只能用c/c++代码,而且cpp文件include的头文件中,也不能出现obj- c的代码,因为cpp只是cpp。<br>2) 在mm文件中混用cpp直接使用即可,所以obj-c混cpp不是问题<br>3)在cpp中混用obj- c其实就是使用obj-c编写的模块是我们想要的。如果模块以类实现,那么要按照cpp class的标准写类的定 义,头文件中不能出现obj-c的东西,包括#import cocoa的。 实现文件中,即类的实现代码中可以使用obj-c的东西,可以import,只是后缀是mm。如果模块以函数实现,那么头文件要按 c的格 式声明函数,实现文件中,c++函数内部可以用obj-c,但后缀还是mm或m。总结:只要cpp文件和cpp include的文件中不包含 obj-c的东西就可以用了,cpp混用obj-c的关键是使用接口,而不能直接使用实现代码,实际上cpp混用的是obj-c编译后的o文 件,这个东西其实是无差别的,所以可以用。obj-c的编译器支持cpp</p>
<h3 id="26-举出5个以上你所熟悉的ios-sdk库有哪些和第三方库有哪些"><a href="#26-举出5个以上你所熟悉的ios-sdk库有哪些和第三方库有哪些" class="headerlink" title="26.举出5个以上你所熟悉的ios sdk库有哪些和第三方库有哪些?"></a>26.举出5个以上你所熟悉的ios sdk库有哪些和第三方库有哪些?</h3><p>ios-sdk:<br>Foundation.framework,CoreGraphics.framework,UIKit.framework, MediaPlayer.framework, CoreAudio.framework<br>第三方库: 1.json编码解码MJExtension;2.ASIHTTPRequest等相关协议封装;3.MJRefresh下拉刷新代码;4.AsyncImageView 异步加载图片并缓存;5.SDWebImage——简化网络图片处理6.SVProgressHUD;7.AFNetworking</p>
<h3 id="27-UITableView的重用机制-如何在一个view上显示多个tableView-tableView要求不同的数据源以及不同的样式-要求自定义cell-如何组织各个tableView的delegate和dataSource-请说说实现思路-在一个tableView-中需要自定义多种样式的cell-两种或三种-通常你如何实现-说说思路即可-UITableView的那些元素是可以自定义的"><a href="#27-UITableView的重用机制-如何在一个view上显示多个tableView-tableView要求不同的数据源以及不同的样式-要求自定义cell-如何组织各个tableView的delegate和dataSource-请说说实现思路-在一个tableView-中需要自定义多种样式的cell-两种或三种-通常你如何实现-说说思路即可-UITableView的那些元素是可以自定义的" class="headerlink" title="27.UITableView的重用机制?如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView的delegate和dataSource?请说说实现思路?在一个tableView 中需要自定义多种样式的cell(两种或三种),通常你如何实现,说说思路即可?UITableView的那些元素是可以自定义的?"></a>27.UITableView的重用机制?如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView的delegate和dataSource?请说说实现思路?在一个tableView 中需要自定义多种样式的cell(两种或三种),通常你如何实现,说说思路即可?UITableView的那些元素是可以自定义的?</h3><p><strong>UITableView的重用机制:</strong><br>查看UITableView头文件,会找到NSMutableArray<em>visiableCells,和NSMutableArray</em>reusableTableCells两 个结构。visiableCells内保存当前显示的cells,reusableTableCells保存可重用的cells。 TableView显示之初,reusableTableCells为空,那么<br>tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都 是通过 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 来创 建,而且cellForRowAtIndexPath只是调用最大显示cell数的次数。 比如:有100条数据,iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是:</p>
<ol>
<li>用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell,并给cell指定同样的重用标识(当然,可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加 入到 visiableCells数组,reusableTableCells为空。</li>
<li>向下拖动tableView,当cell1完全移出屏幕,并且 cell11(它也是alloc出来的,原因同上)完全显示出来的时候。 cell11加入到visiableCells,cell1移出 visiableCells,cell1加入到reusableTableCells。</li>
<li>接着向下拖动tableView,因为reusableTableCells中已 经有值,所以,当需要显示新的cell, cellForRowAtIndexPath再次被调用的时 候,<br>tableView dequeueReusableCellWithIdentifier:CellIdentifier,返回cell1。 cell1加入到visiableCells,cell1 移出reusableTableCells;cell2移出 visiableCells,cell2加入到reusableTableCells。之后再需要显示的Cell就可 以正常重用了􏰂</li>
</ol>
<h3 id="28-OC中的数字对象都有哪些-简述它们与基本数据类型的区别是什么"><a href="#28-OC中的数字对象都有哪些-简述它们与基本数据类型的区别是什么" class="headerlink" title="28.OC中的数字对象都有哪些,简述它们与基本数据类型的区别是什么"></a>28.OC中的数字对象都有哪些,简述它们与基本数据类型的区别是什么</h3><p>Objective-C中的数字对象NSNumber;<br>Objective-C中的基本类型和C语言中的基本类型一样.主要有:int,long,float,double,char,void,bool等. 对于基本类型变量,不需要用指针,也不用手动回收,方法执行结束会自动回收.数字对象需要指针,也需要手动回收内存。</p>
<h3 id="29-OC中所有对象间的交互是如何实现的"><a href="#29-OC中所有对象间的交互是如何实现的" class="headerlink" title="29.OC中所有对象间的交互是如何实现的?"></a>29.OC中所有对象间的交互是如何实现的?</h3><p><strong>通过指针实现的</strong></p>
<h3 id="30-objective-c中的类型转换分为哪几类"><a href="#30-objective-c中的类型转换分为哪几类" class="headerlink" title="30.objective-c中的类型转换分为哪几类?"></a>30.objective-c中的类型转换分为哪几类?</h3><p>可变与不可变之间的转化;<br>可变与可变之间的转化;<br>不可变与不可变之间。</p>
<h3 id="31-类变量的-protected-private-public-package声明各有什么含义"><a href="#31-类变量的-protected-private-public-package声明各有什么含义" class="headerlink" title="31.类变量的@protected ,@private,@public,@package声明各有什么含义?"></a>31.类变量的@protected ,@private,@public,@package声明各有什么含义?</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">变量的作用域不同,<span class="keyword">@protected</span> 该类和所有子类中 的方法可以直接访问这样的变量,这是默认的;  </div><div class="line"><span class="keyword">@private</span> 该类中的方法可以访问这样的变量,子类不可以; <span class="keyword">@public</span>除了自己和子类方法外,也可以被其他类或者其他模块中的方法访问;  </div><div class="line"><span class="keyword">@package</span> 目前尚未得出结论</div></pre></td></tr></table></figure>
<h3 id="32-什么是序列化或者Acrchiving-可以用来做什么-怎样与copy结合-原理是什么"><a href="#32-什么是序列化或者Acrchiving-可以用来做什么-怎样与copy结合-原理是什么" class="headerlink" title="32.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?."></a>32.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.</h3><p><strong>序列化就是:归档</strong></p>
<h3 id="33-NSArray和NSMutableArray的区别-多线程操作哪个更安全"><a href="#33-NSArray和NSMutableArray的区别-多线程操作哪个更安全" class="headerlink" title="33.NSArray和NSMutableArray的区别,多线程操作哪个更安全?"></a>33.NSArray和NSMutableArray的区别,多线程操作哪个更安全?</h3><p><strong>NSArray更安全,当同时被访问时,NSArray是不可改变</strong></p>
<h3 id="34-当前有一个数组-里面有若干重复的数据-如何去除重复的数据"><a href="#34-当前有一个数组-里面有若干重复的数据-如何去除重复的数据" class="headerlink" title="34.当前有一个数组,里面有若干重复的数据,如何去除重复的数据?"></a>34.当前有一个数组,里面有若干重复的数据,如何去除重复的数据?</h3><p><strong>可以由数组,到集合</strong></p>
<h3 id="35-isKindOfClass、isMemberOfClass、selector作用分别是什么"><a href="#35-isKindOfClass、isMemberOfClass、selector作用分别是什么" class="headerlink" title="35.isKindOfClass、isMemberOfClass、selector作用分别是什么"></a>35.isKindOfClass、isMemberOfClass、selector作用分别是什么</h3><p>isKindOfClass,作用是,某个对象属于某个类型,包括继承的类型—<br>isMemberOfClass:某个对象确切属于某个类型,是不是具体的实例<br>selector:通过方法名,获取在内存中的函数的入口地址</p>
<h3 id="36-写出下面程序段的输出结果"><a href="#36-写出下面程序段的输出结果" class="headerlink" title="36.写出下面程序段的输出结果"></a>36.写出下面程序段的输出结果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@"a string value"</span> forKey:<span class="string">@"akey"</span>];  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [dict objectForKey:<span class="string">@"akey"</span>]);  </div><div class="line">[dict release];</div></pre></td></tr></table></figure>
<p><strong>打印输出 a string value,然后崩溃—-原因:便利构造器创建的对象,之后的release,会造成过度释放</strong></p>
<h3 id="37-请写出以下代码的执行结果"><a href="#37-请写出以下代码的执行结果" class="headerlink" title="37.请写出以下代码的执行结果"></a>37.请写出以下代码的执行结果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * name = [ [ <span class="built_in">NSString</span> alloc] init ];  </div><div class="line">name = @”Habb”;  </div><div class="line">[name release];</div></pre></td></tr></table></figure>
<p>打印输出结果是: Habb,在[name release]前后打印均有输出结果 —会造成内存泄露—原先指向的区域变成了野指针,之后的释放,不能释放之前创建的区域</p>
<h1 id="二、网络与多线程"><a href="#二、网络与多线程" class="headerlink" title="二、网络与多线程"></a>二、网络与多线程</h1><h3 id="1-HTTP协议详解"><a href="#1-HTTP协议详解" class="headerlink" title="1.HTTP协议详解"></a>1.HTTP协议详解</h3><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中。<br>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。<br>HTTP协议的主要特点可概括如下：<br>1.支持客户/服务器模式。<br>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。(短连接)<br>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2.URL"></a>2.URL</h3><p>HTTP URL (URL是一种特殊类型的URI是他的子类，包含了用于查找某个资源的足够的信息)的格式如下：<br><a href="http://host[&quot;:&quot;port][abs_path" target="_blank" rel="external">http://host[&quot;:&quot;port][abs_path</a>]<br>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80;<br>abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</p>
<h3 id="3-TCP-UDP区别联系"><a href="#3-TCP-UDP区别联系" class="headerlink" title="3.TCP/UDP区别联系"></a>3.TCP/UDP区别联系</h3><p>TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快 </p>
<h5 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h5><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，我们来看看这三次对话的简单过程：1.主机A向主机B发出连接请求数据包；2.主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包；3.主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。<br>tcp协议和udp协议的差别<br>是否连接面向连接面向非连接<br>传输可靠性可靠不可靠<br>应用场合传输大量数据少量数据<br>速度慢快</p>
<h3 id="4-socket连接和http连接的区别"><a href="#4-socket连接和http连接的区别" class="headerlink" title="4.socket连接和http连接的区别"></a>4.socket连接和http连接的区别</h3><p>简单说，你浏览的网页（网址以<a href="http://开头)都是http协议传输到你的浏览器的" target="_blank" rel="external">http://开头)都是http协议传输到你的浏览器的</a>, 而http是基于socket之上的。socket是一套完成tcp，udp协议的接口。<br>HTTP协议：简单对象访问协议，对应于应用层  ，HTTP协议是基于TCP连接的<br>tcp协议：    对应于传输层<br>ip协议：     对应于网络层<br>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。<br>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。<br>http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉；<br>socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息~~具体心跳消息格式是开发者自己定义的<br>我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。<br>1)Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层.<br>而http是个应用层的协议，它实际上也建立在TCP协议之上。<br>(HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。)<br>2）Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p>
<h3 id="5-什么是TCP连接的三次握手"><a href="#5-什么是TCP连接的三次握手" class="headerlink" title="5.什么是TCP连接的三次握手"></a>5.什么是TCP连接的三次握手</h3><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）</p>
<h3 id="6-利用Socket建立网络连接的步骤"><a href="#6-利用Socket建立网络连接的步骤" class="headerlink" title="6.利用Socket建立网络连接的步骤"></a>6.利用Socket建立网络连接的步骤</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>1.服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>2.客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>3.连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="7-TCP-IP通信建立的过程怎样，端口有什么作用"><a href="#7-TCP-IP通信建立的过程怎样，端口有什么作用" class="headerlink" title="7.TCP/IP通信建立的过程怎样，端口有什么作用"></a>7.TCP/IP通信建立的过程怎样，端口有什么作用</h3><p>三次握手，确定是哪个应用程序使用该协议</p>
<h3 id="8-进程和线程的差别"><a href="#8-进程和线程的差别" class="headerlink" title="8.进程和线程的差别"></a>8.进程和线程的差别</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体.(线程是进程的基本单位)<br>与进程的区别:<br>(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br>(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行<br>(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.<br>(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。  </div><div class="line">2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。  </div><div class="line">两者都可以提高程序的并发度，提高程序运行效率和响应时间。  </div><div class="line">线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。</div></pre></td></tr></table></figure></p>
<h3 id="9-简述多线程的作用以及什么地方会用到多线程-OC实现多线程的方法有哪些-谈谈多线程安全问题的几种解决方案-何为线程同步-如何实现的-分线程回调主线程方法是什么-有什么作用"><a href="#9-简述多线程的作用以及什么地方会用到多线程-OC实现多线程的方法有哪些-谈谈多线程安全问题的几种解决方案-何为线程同步-如何实现的-分线程回调主线程方法是什么-有什么作用" class="headerlink" title="9.简述多线程的作用以及什么地方会用到多线程?OC实现多线程的方法有哪些?谈谈多线程安全问题的几种解决方案?何为线程同步,如何实现的?分线程回调主线程方法是什么,有什么作用?"></a>9.简述多线程的作用以及什么地方会用到多线程?OC实现多线程的方法有哪些?谈谈多线程安全问题的几种解决方案?何为线程同步,如何实现的?分线程回调主线程方法是什么,有什么作用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(1)、多线程的作用:可以解决负载均衡问题,充分利用cpu资源 。为了提高CPU的使用率,采用多线程的方式去同时完 成几件事情而互不干扰,  </div><div class="line">(2)、大多情况下,要用到多线程的主要是需要处理大量的IO操作时或处理的情况需要花大量的时间等等,比如:读写文 件、视频图像的采集、处理、显示、保存等。   </div><div class="line">(3)、ios有三种主要方法:1、NSThread。2、NSOperation。3、GCD。  </div><div class="line">(4)解决方案:使用锁:锁是线程编程同步工具的基础。锁可以让你很容易保护代码中一大块区域以便你可以确保代码的正 确性。使用POSIX互斥锁;使用NSLock类;使用@synchronized指令等。  </div><div class="line">(5)回到主线程的方法:    </div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);作用:主线程是显示UI界面,子线程多数是进行数据处理</div></pre></td></tr></table></figure>
<h3 id="10-http和scoket通信的区别-socket连接相关库-TCP-UDP的连接方法-HTTP的几种常用方式-http和scoket通信的区别"><a href="#10-http和scoket通信的区别-socket连接相关库-TCP-UDP的连接方法-HTTP的几种常用方式-http和scoket通信的区别" class="headerlink" title="10.http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? http和scoket通信的区别"></a>10.http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? http和scoket通信的区别</h3><p>http是客户端用http协议进行请求,发送请求时候需要封装http请求头,并绑定请求的数据,服务器一般有web服务器配 合(当然也非绝对)。 http请求方式为客户端主动发起请求,服务器才能给响应,一次请求完毕后则断开连接,以节省资 源。服务器不能主动给客户端响应(除非采取http长连接技术)。iphone主要使用类是NSUrlConnection。 scoket是客户端跟服务器直接使用socket“套接字”进行连接,并没有规定连接后断开,所以客户端和服务器可以保持连 接通道,双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使 用。主要使用类是CFSocketRef。 UDP:是用户数据报协议:主要用在实时性要求高以及对质量相对较弱的地方,但面对现在高质量的线路不是容易丢包除非 是一些拥塞条件下 ,如流媒体 TCP:是传输控制协议:是面连接的,那么运行环境必然要求其可靠性不可丢包有良好的拥塞控制机制如http ftp telnet 等<br>http的常用方式:get,post</p>
<h3 id="11-你连接服务器用的是什么方法-如果请求过程中-网络出了问题这么办"><a href="#11-你连接服务器用的是什么方法-如果请求过程中-网络出了问题这么办" class="headerlink" title="11.你连接服务器用的是什么方法,如果请求过程中,网络出了问题这么办?"></a>11.你连接服务器用的是什么方法,如果请求过程中,网络出了问题这么办?</h3><p>NSUrlConnection 连接后,有一系列委托方法来接受来自服务器的响应和数据,其中接受相应的方法回得到服务器要传 回的数据有多大,接受数据的方法会反复调用来不断接受服务器数据,如果网络出了问题了,会调用一个方法让你来做相关处理。</p>
<h3 id="12-NSOperation-queue"><a href="#12-NSOperation-queue" class="headerlink" title="12.NSOperation queue?"></a>12.NSOperation queue?</h3><p>答案：存放NSOperation的集合类。<br>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。<br>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。<br>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。<br>但是转念一想其实可以参考银行的取票和叫号系统。<br>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。<br>但是后来看到一票关于这操作队列话题的文章，其中有一句提到“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”<br>瞬间觉得这个queue名字有点忽悠人了，还不如pool~<br>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</p>
<h3 id="13-死锁"><a href="#13-死锁" class="headerlink" title="13.死锁"></a>13.死锁</h3><p><strong>在主线程里面执行同步操作</strong></p>
<h3 id="14-AFN-SDWebImage"><a href="#14-AFN-SDWebImage" class="headerlink" title="14.AFN/SDWebImage"></a>14.AFN/SDWebImage</h3><h3 id="15-同步锁"><a href="#15-同步锁" class="headerlink" title="15.同步锁"></a>15.同步锁</h3><p>多个线程同时修改一个资源需要加锁（++i 不需要，i++需要）</p>
<h3 id="16-GCD和NSOperation"><a href="#16-GCD和NSOperation" class="headerlink" title="16.GCD和NSOperation   "></a>16.GCD和NSOperation   </h3><p>NSOperation:                         可以方便的对线程进行管理<br>             1.         可以设置最大线程数<br>          2.可以停止线程         <br>3.设置线程间的依赖关系 <br>GCD：一旦线程开始，就无法停止，而且不能统一管理</p>
<h1 id="三、Other"><a href="#三、Other" class="headerlink" title="三、Other"></a>三、Other</h1><h3 id="1-如何将产品进行多语言发布"><a href="#1-如何将产品进行多语言发布" class="headerlink" title="1.如何将产品进行多语言发布?"></a>1.如何将产品进行多语言发布?</h3><p>程序国际化;<br>比如:本地化应用程序名称<br>(1、选中工程,Info—Localizations点击“+”添加要国际化的语言。<br>(2、在InfoPlist.strings右边会多出一个三角形,点击展开可看到InfoPlish.strings(english)和<br>InfoPlish.strings(chinese)两个版本的文件;<br>(3、在InfoPlish.strings(english)文件中加入:<br>CFBundleDisplayName =”Program”; 其中“Program”为英文应用程序名称,同理在InfoPlish.strings(chinese)文件中加入: CFBundleDisplayName =”应用程序”; 其中“应用程序”为中文名称,注意:CFBundleDisplayName加不加双引号都行;<br>(4、编辑Info.plist,添加一个新的属性Application has localized display name, 设置其类型为boolean,并将其 value设置为YES即可。</p>
<h3 id="2-什么是动态链接库和静态链接库-调用一个类的静态方法需不需要release"><a href="#2-什么是动态链接库和静态链接库-调用一个类的静态方法需不需要release" class="headerlink" title="2.什么是动态链接库和静态链接库?调用一个类的静态方法需不需要release?"></a>2.什么是动态链接库和静态链接库?调用一个类的静态方法需不需要release?</h3><p>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序,程序运行的时候不再需要其它的库文件;动态链接就是 把调用的函数所在文件模块 (DLL)和调用函数在文件中的位置等信息链接进目标程序,程序运行的时候再从DLL中寻找 相应函数代码,因此需要相应DLL文件的支持。 静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库,而在动态链接库中还 可以再包含其他的动态或静态链接库。<br>动态的是:运行时才加载到内存中,静态:编译时就加载到内存中 静态方法也就是类方法,不需要release</p>
<h3 id="3-什么是push-远程推送"><a href="#3-什么是push-远程推送" class="headerlink" title="3.什么是push?远程推送"></a>3.什么是push?远程推送</h3><p>第一步:UIApplication向APNS注册push notification服务<br>1、应用程序 要支持 推送服务(在网页里配置)<br>(1)<a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">https://developer.apple.com/devcenter/ios/index.action</a><br>(2)登录 苹果开发者账号(注意是收费账号,$99或$299)<br>(3)下载push证书(主要是给程序签名,push服务只有收费开发者才具备。所以需要签名验证),如果没有 push证书,创建一个push证书(App ID-&gt;钥匙串程序生成request-&gt;push证书)注意事项:App ID的 Bundle ID必须和程序plist文件里的Bundle identifier一致。App ID一旦生成,将不可修改。<br>(4)把证书安装到钥匙串里(双击证书文件)<br>(5)生成 编译程序 用的描述文件(网页里进行)<br>2、向APNS注册push服务(UIApplication的registerForRemoteNotificationTypes:方法)<br>第二步 获取APNS分配的DeviceToken(64位16进制串)</p>
<pre><code class="objc">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken
</code></pre>
<p>第三步 把DeviceToken发送给自己的后台服务器,服务器记录每台设备的DeviceToken以便日后推送信息给客 户端。(需要有一个网络接口,让客户端发送DeviceToken)<br>第四步 服务器推送信息给客户端<br>1、服务器除了需要有客户端的DeviceToken之外,还要有push证书,对push的内容进行签名。(苹果为了防 止 恶意向客户端(比如DeviceToken泄露了)发送消息,每次推送消息,都需要证书进行签名,从而避免黑客恶 意攻击用户手机。)<br>2、如果你的服务器是java写的,可以直接使用钥匙串导出的p12文件(证书和密钥一起导出)。如果你的服务器 是php写的,因为php语言不支持p12文件类型,需要转换为pem文件。<br>3、将p12转换为pem文件:终端 先找到你p12所在的目录 openssl pkcs12 -in CertificateName.p12 - outCertificateName.pem -nodes<br>4、服务器发送信息给APNS,APNS自动将信息推送给客户端<br>第五步 客户端处理收到的信息</p>
<pre><code class="objc">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo
</code></pre>
<p>注意事项<br>1、测试版的push证书仅仅用于开发期间测试,发布版的程序需要生成一个发布版的push证书。 2、测试版APNS的ssl地址和发布版的ssl地址不同 3、测试版的DeviceToken和发布版的DeviceToken也不同<br>4、php文件要喝pem文件放在同一目录。<br>5、除了alert sound和badge之外,json串里还可以包含自定义信息。<br>6、推送的信息最大255字节 7、推送的信息受网络影响较大,有可能造成延迟甚至丢失,重要信息的传递不应该使用push通知,应该有专门的 后台接口。<br>8、借助push推送,两个客户端可以实现即时通信,工程里面存放我们的p12文件,客户端自己组织json串,发 送请求到APNS。</p>
<h3 id="4-iphone阅读器-如果要读取一个文本文件-请问你是如何处理编码问题的-另外像pdf格式的文件-你如何读取"><a href="#4-iphone阅读器-如果要读取一个文本文件-请问你是如何处理编码问题的-另外像pdf格式的文件-你如何读取" class="headerlink" title="4.iphone阅读器,如果要读取一个文本文件,请问你是如何处理编码问题的?另外像pdf格式的文件,你如何读取?"></a>4.iphone阅读器,如果要读取一个文本文件,请问你是如何处理编码问题的?另外像pdf格式的文件,你如何读取?</h3><p>首先检测文本编码格式(只需读取小部分用来判断), iphone手机阅读器中对于PDF格式的阅读,可以直接用UIWebView控件显示,也可以从网上下到很多直接读取pdf格式 的代码<br>直接从pdf中得到数据。复杂表格动画</p>
<pre><code class="objc">- (<span class="keyword">void</span>)insertRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation:(<span class="built_in">UITableViewRowAnimation</span>)animation;
- (<span class="keyword">void</span>)deleteRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation: (<span class="built_in">UITableViewRowAnimation</span>)animation;  
- (<span class="keyword">void</span>)reloadRowsAtIndexPaths:(<span class="built_in">NSArray</span> *)indexPaths withRowAnimation:(<span class="built_in">UITableViewRowAnimation</span>)animation;
</code></pre>
<h3 id="5-iphone-app为什么会被打回来-如何制止"><a href="#5-iphone-app为什么会被打回来-如何制止" class="headerlink" title="5.iphone app为什么会被打回来,如何制止?"></a>5.iphone app为什么会被打回来,如何制止?</h3><p>app的设置界面、按钮使用了类似iphone的操作方式以及icon的圆角设计 -&gt; 重新设计⋯<br>  app的年龄设置太低 -&gt; 改了年龄⋯<br>  app里有实物奖励 -&gt; 免责声明,和苹果无关⋯<br>  app描述里提了后续版本的功能的字样 -&gt; 删除⋯<br>  app有打分的功能 -&gt; 有reject的,也有通过的⋯<br>  app需要使用location,没有提示用户 -&gt; 加了提示,允许用户拒绝⋯<br>  app没提供测试账号 -&gt; 提供⋯<br>app里有私有api -&gt; 修改⋯ 应用内含有有某公司LOGO的图片,没有该公司授权文件,被拒-&gt; 修改⋯<br>第三方静态库包含私有api的调用(联系第三方技术支持,更新静态库); 包含潜在的色情,暴力等内容(调整应用年龄限制等级,并加入举报功能) 做浏览器的,分级必须选17+</p>
<h3 id="6-iphone应用程序的项目基本结构"><a href="#6-iphone应用程序的项目基本结构" class="headerlink" title="6.iphone应用程序的项目基本结构?"></a>6.iphone应用程序的项目基本结构?</h3><p>· Classes -&gt; 源程序文件(.h、.m)<br>· Other Sources-&gt; main.m 等,不需要程序员修改 -Prefix.pch<br>· Resources -&gt; 界面文件(.xib)、配置文件-info.plist<br>· Frameworks -&gt; 链接的库· Targets -&gt; 项目的不同Target(资源、编译配置不同)<br>· Executables -&gt; 项目中所有的可执行文件 -Prefix.pch:_Prefix为所有的项目程序文件预先配置运行环境的前缀标头,在程序运行之前,引入所需框架中的(.h)头文 件。这样可以减少每个头文件对程序编译做出相同的定义,在巨型的应用程序项目开发中节省大量的时间,例如,程序有 100个根文件需要定义abc.h,只需要在_Preix.pch文件下建立一个对象,所有的根文件便可以重复地对程序编译做出定 义。</p>
<h3 id="7-ViewController的loadView-viewDidLoad-viewWillAppear-viewDidUnload-dealloc、init分别是在什么时候调用的-在自定义ViewController的时候这几个函数里面应该做什么工作"><a href="#7-ViewController的loadView-viewDidLoad-viewWillAppear-viewDidUnload-dealloc、init分别是在什么时候调用的-在自定义ViewController的时候这几个函数里面应该做什么工作" class="headerlink" title="7.ViewController的loadView,viewDidLoad,viewWillAppear,viewDidUnload,dealloc、init分别是在什么时候调用的?在自定义ViewController的时候这几个函数里面应该做什么工作?"></a>7.ViewController的loadView,viewDidLoad,viewWillAppear,viewDidUnload,dealloc、init分别是在什么时候调用的?在自定义ViewController的时候这几个函数里面应该做什么工作?</h3><p>1、viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用<br>2、viewDidUnload当系统内存吃紧的时候会调用该方法,在该方法中将所有IBOutlet(无论是property还是实例变量) 置 为nil(系统release view时已经将其release掉了)在该方法中释放其他与view有关的对象、其他在运行时创建(但 非系统必须)的对象、在viewDidLoad中 被创建的对象、缓存数据等 release对象后,将对象置为nil(IBOutlet只需要 将其置为nil,系统release view时已经将其release掉了) dealloc方法,viewDidUnload和dealloc方法没有关联,dealloc还是继续做它该做的事情<br>流程应该是这样:<br>(loadView/nib文件)来加载view到内存 –&gt;viewDidLoad函数进一步初始化这些view –&gt;内存不足时,调用 viewDidUnload函数释放views –&gt;当需要使用view时有回到第一步<br>如此循环<br>4、viewWillAppear方法,视图即将过渡到屏幕上时调用,(一般在返回需要刷新页面时,我都选择使用代理,所以很少用到)<br>5、viewWillDisappear方法,这个A-&gt;B之后,A在B之后的操作</p>
<h3 id="8-描述程序启动的顺序"><a href="#8-描述程序启动的顺序" class="headerlink" title="8.描述程序启动的顺序"></a>8.描述程序启动的顺序</h3><p>1、main.m是程序的入口<br>2、UIApplicationMain()创建应用程序对象,并且为此对象指定委托,检测程序的执行,同时开启事件循环,处理程序接收到的事 件<br>3、UIApplicationDelegate方法的执行<br>4、加载window<br>5、指定根视图控制器 6、在指定的试图控制器中添加控件,实现应用程序界面</p>
<h3 id="9-描述下拉刷新的实现机制"><a href="#9-描述下拉刷新的实现机制" class="headerlink" title="9.描述下拉刷新的实现机制?"></a>9.描述下拉刷新的实现机制?</h3><p><strong>获取数据,刷新页面</strong></p>
<h3 id="10-简述应用程序按Home键进入后台时的生命周期-和从后台回到前台时的生命周期"><a href="#10-简述应用程序按Home键进入后台时的生命周期-和从后台回到前台时的生命周期" class="headerlink" title="10.简述应用程序按Home键进入后台时的生命周期,和从后台回到前台时的生命周期?"></a>10.简述应用程序按Home键进入后台时的生命周期,和从后台回到前台时的生命周期?</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">应用程序:  </div><div class="line">-[AppDelegate application:willFinishLaunchingWithOptions:]  </div><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:]  </div><div class="line">-[AppDelegate applicationDidBecomeActive:]   </div><div class="line">退到后台:  </div><div class="line">-[AppDelegate applicationWillResignActive:]   </div><div class="line">-[AppDelegate applicationDidEnterBackground:]   </div><div class="line">回到前台:  </div><div class="line">-[AppDelegate applicationWillEnterForeground:]   </div><div class="line">-[AppDelegate applicationDidBecomeActive:]   </div><div class="line">ViewController之间加载页面:  </div><div class="line">-[mainViewController viewDidLoad]   </div><div class="line">-[mainViewController viewWillAppear:]   </div><div class="line">-[mainViewController viewWillLayoutSubviews]   </div><div class="line">-[mainViewController viewDidLayoutSubviews]   </div><div class="line">-[mainViewController viewDidAppear:]   </div><div class="line">退出当前页面:  </div><div class="line">-[mainViewController viewWillDisappear:]  </div><div class="line">-[mainViewController viewDidDisappear:]  </div><div class="line">返回之前页面:  </div><div class="line">-[mainViewController viewWillAppear:]  </div><div class="line">-[mainViewController viewWillLayoutSubviews]  </div><div class="line">-[mainViewController viewDidLayoutSubviews]  </div><div class="line">-[mainViewController viewDidAppear:]</div></pre></td></tr></table></figure>
<h3 id="11-简述值传递和引用传递的区别"><a href="#11-简述值传递和引用传递的区别" class="headerlink" title="11.简述值传递和引用传递的区别?"></a>11.简述值传递和引用传递的区别?</h3><p>所谓值传递,就是说仅将对象的值传递给目标对象,就相当于copy;系统将为目标对象重新开辟一个完全相同的内存空间。 所谓引用传递,就是说将对象在内存中的地址传递给目标对象,就相当于使目标对象和原始对象对应同一个内存存储空间。此时,如 果对目标对象进行修改,内存中的数据也会改变。</p>
<h3 id="12-说说如何进行后台运行程序"><a href="#12-说说如何进行后台运行程序" class="headerlink" title="12.说说如何进行后台运行程序?"></a>12.说说如何进行后台运行程序?</h3><p>答:判断是否支持多线程<br>UIDevice* device = [UIDevice currentDevice];<br>BOOL backgroundSupported = NO;<br>if ([device respondsToSelector:@selector(isMultitaskingSupported)])<br>backgroundSupported = device.multitaskingSupported; 声明你需要的后台任务Info.plist中添加UIBackgroundModes键值,它包含一个或多个string的值,包括audio:在后台提供声音 播放功能,包括音频流和播放视频时的声音 location:在后台可以保持用户的位置信息 voip:在后台使用VOIP功能 前面的每个value让系统知道你的应用程序应该在适当的时候被唤醒。例如,一个应用程序,开始播放音乐,然后移动到后台仍然需要 执行时间,以填补音频输出缓冲区。添加audio键用来告诉系统框架,需要继续播放音频,并且可以在合适的时间间隔下回调应用程 序;如果应用程序不包括此项,任何音频播放在移到后台后将停止运行。除了添加键值的方法,IOS还提供了两种途径使应用程序在后 台工作:<br>Task completion—应用程序可以向系统申请额外的时间去完成给定的任务<br>Local notifications—应用程序可以预先安排时间执行local notifications 传递实现长时间的后台任务:应用程序可以请求在后台 运行以实现特殊的服务。这些应用程序并不连续的运行,但是会被系统框架在合适的时间唤醒,以实现这些服务</p>
<h3 id="13-简述你对UIView、UIWindow和CALayer的理解"><a href="#13-简述你对UIView、UIWindow和CALayer的理解" class="headerlink" title="13.简述你对UIView、UIWindow和CALayer的理解"></a>13.简述你对UIView、UIWindow和CALayer的理解</h3><p>UIView:属于UIkit.framework框架,负责渲染矩形区域的内容,为矩形区域添加动画,响应区域的触摸事件,布局和管 理一个或多个子视图<br>UIWindow:属于UIKit.framework框架,是一种特殊的UIView,通常在一个程序中只会有一个UIWindow,但可以手 动创建多个UIWindow,同时加到程序里面。UIWindow在程序中主要起到三个作用:<br>1、作为容器,包含app所要显示的所有视图<br>2、传递触摸消息到程序中view和其他对象<br>3、与UIViewController协同工作,方便完成设备方向旋转的支持<br>CAlayer:属于QuartzCore.framework,是用来绘制内容的,对内容进行动画处理依赖与UIView来进行显示,不能处 理用户事件。UIView和CALayer是相互依赖的,UIView依赖CALayer提供内容,CALayer依赖UIView一共容器显示 绘制内容。<br>延伸: UIViewController:管理视图的几成熟,每个视图控制器都有一个自带的视图,并且负责这个视图相关的一切事务。方便 管理视图中的子视图,负责model与view的通信;检测设备旋转以及内存警告;是所有视图控制类的积累,定义了控制器 的基本功能。<br>UIResponder的那张图</p>
<p>1.CALayer                                                                      负责内容的显示，渲染<br>2.CALayer不响应触摸事件        </p>
<h3 id="14-frame和bounds有什么不同"><a href="#14-frame和bounds有什么不同" class="headerlink" title="14.frame和bounds有什么不同"></a>14.frame和bounds有什么不同</h3><p>答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）<br>bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）</p>
<h3 id="15-position-anchorPoint"><a href="#15-position-anchorPoint" class="headerlink" title="15.position/anchorPoint"></a>15.position/anchorPoint</h3><p>position:决定layer在父视图的位置<br>anchorPoint：决定position在本身的位置，anchorPoint取值范围：（0，1），默认（0.5，0.5）；</p>
<h3 id="16-What-is-lazy-loading"><a href="#16-What-is-lazy-loading" class="headerlink" title="16.What is lazy loading?"></a>16.What is lazy loading?</h3><p>答案：懒汉模式，只在用到的时候才去初始化。<br>也可以理解成延时加载。<br>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。<br>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>
<h3 id="17-app省电技巧"><a href="#17-app省电技巧" class="headerlink" title="17.app省电技巧"></a>17.app省电技巧</h3><p>1.后台定位不要太频繁<br>2.蓝牙作为周边设备,进入后台后广播频率降低<br>3.尽可能降低CPU使用率,线程及时进入休眠</p>
<h3 id="18-APP升级"><a href="#18-APP升级" class="headerlink" title="18.APP升级"></a>18.APP升级</h3><p>Documents                            iCloud    <br>Library               Library/Caches               <br>tmp                        <br>app升级时,Document,Library不会被覆盖。应该将app版本号保存 在本地。</p>
<ol>
<li>如果启动发现版本号比本地版本号大,则弹出引导页</li>
<li>正式进入app之后,跟新本地存储的app版本号</li>
</ol>
<h3 id="19-block"><a href="#19-block" class="headerlink" title="19.block"></a>19.block</h3><p>1.全局block:如果没有用到局部变量就是全局block,对其copy不会有影响<br>2.栈block:如果用到局部变量,就是栈block。arc下没有栈block<br>3.堆block:如果对栈block copy,就会变成堆block</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/分类（Category）/" itemprop="url">
                  分类（Category）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-15T10:31:23+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、分类（Category）概念及使用流程"><a href="#一、分类（Category）概念及使用流程" class="headerlink" title="一、分类（Category）概念及使用流程"></a>一、分类（Category）概念及使用流程</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 学习引入：</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> :<span class="title">NSObject</span> </span></div><div class="line">-(<span class="keyword">void</span>)run;</div><div class="line">-(<span class="keyword">void</span>)eat;</div><div class="line">-(<span class="keyword">void</span>)study;</div><div class="line"><span class="keyword">@end</span> -(<span class="keyword">void</span>)playlol;</div></pre></td></tr></table></figure>
<h4 id="1、分类的概念及作用"><a href="#1、分类的概念及作用" class="headerlink" title="1、分类的概念及作用"></a>1、分类的概念及作用</h4><h5 id="1、分类的概念："><a href="#1、分类的概念：" class="headerlink" title="1、分类的概念："></a>1、分类的概念：</h5><ul>
<li>Category：类别、类目、分类。</li>
</ul>
<h5 id="2、分类的作用"><a href="#2、分类的作用" class="headerlink" title="2、分类的作用"></a>2、分类的作用</h5><ul>
<li>1）将1个类中的不同方法分到多个不同的文件中存储，便于对类进行模块化设计和团队开发。</li>
<li>2）可以在不修改原来类的基础上，为这个类扩充一些方法。</li>
<li>3）注意：<ul>
<li>分类中只能增加“方法”，不能增加成员变量。</li>
<li>分类中可以访问原来类中的成员变量。</li>
</ul>
</li>
</ul>
<h5 id="3、使用分类的目的"><a href="#3、使用分类的目的" class="headerlink" title="3、使用分类的目的"></a>3、使用分类的目的</h5><ul>
<li>1）对现有类进行扩展:<ul>
<li>比如,你可以扩展Cocoa touch框架中的类,你在类别中增加的方法会被子类所继承,而且在运行 时跟其他的方法没有区别。</li>
</ul>
</li>
<li>2）作为子类的替代手段:<ul>
<li>不需要定义和使用一个子类,你可以通过类别直接向已有的类里增加方法。</li>
</ul>
</li>
<li>3）对类中的方法归类:<ul>
<li>利用category把一个庞大的类划分为小块来分别进行开发,从而更好的对类中的方法进行更新和维护。</li>
</ul>
</li>
</ul>
<h5 id="4、分类的使用流程"><a href="#4、分类的使用流程" class="headerlink" title="4、分类的使用流程"></a>4、分类的使用流程</h5><ul>
<li>声明分类–&gt;实现分类–&gt;使用分类</li>
<li>注意:分类的命名规则:类名+扩展方法,如“NSString+countNum”。 分类的接口声明与类的定义十分相似,但分类不继承父类,只需要带有一个括号,表明该分类的主要用途。</li>
</ul>
<h2 id="二、分类（Category）声明和实现"><a href="#二、分类（Category）声明和实现" class="headerlink" title="二、分类（Category）声明和实现"></a>二、分类（Category）声明和实现</h2><h4 id="1、声明和实现一个分类"><a href="#1、声明和实现一个分类" class="headerlink" title="1、声明和实现一个分类"></a>1、声明和实现一个分类</h4><ul>
<li><p>在.h文件中,声明分类:</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> 类名 (分类名)</span></div><div class="line"><span class="comment">//方法;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>说明:</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">声明分类格式</div><div class="line"><span class="number">1</span>）新添加的方法必须写在 <span class="class"><span class="keyword">@interface</span> 与 @<span class="title">end</span> 之间</span></div><div class="line"><span class="number">2</span>）ClassName 现有类的类名(要为哪个类扩展方法)。</div><div class="line"><span class="number">3</span>）CategoryName 待声明的分类名称</div><div class="line"><span class="number">4</span>）NewMethod 新添加的方法</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><ul>
<li><p>不允许在声明分类的时候定义变量</p>
   <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>(<span class="title">sport</span>)</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> _age; <span class="comment">// 报错</span></div><div class="line"> &#125;</div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line">- (<span class="keyword">void</span>)jump;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>在.m文件中(也可以在.h中实现),实现分类:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassName</span>(<span class="title">CategoryName</span>) <span class="title">NewMethod</span></span></div><div class="line">&#123;</div><div class="line">......</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>说明:<ul>
<li>实现类别格式<ul>
<li>1)新方法的实现必须写在@ implementation与@end之间</li>
<li>2)ClassName 现有类的类名</li>
<li>3)CategoryName 待声明的分类名称</li>
<li>4)NewMethod 新添加的方法的实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2、调用分类中的方法"><a href="#2、调用分类中的方法" class="headerlink" title="2、调用分类中的方法"></a>2、调用分类中的方法</h6><ul>
<li>调用分类中的方法与一般方法调用，完全一样（需要导入头文件）</li>
</ul>
<h2 id="三、分类（Catefory）使用注意事项"><a href="#三、分类（Catefory）使用注意事项" class="headerlink" title="三、分类（Catefory）使用注意事项"></a>三、分类（Catefory）使用注意事项</h2><h4 id="1、分类的使用注意事项"><a href="#1、分类的使用注意事项" class="headerlink" title="1、分类的使用注意事项"></a>1、分类的使用注意事项</h4><ul>
<li>1）分类只能增加方法, 不能增加成员变量</li>
<li>2）可以书写@property,此时只生成get和set方法,不会生成私有变量</li>
<li>3)如果分类和原来类出现同名的方法, 优先调用分类中的方法, 原来类中的方法会被屏蔽</li>
</ul>
<h4 id="2、分类的编译的顺序"><a href="#2、分类的编译的顺序" class="headerlink" title="2、分类的编译的顺序"></a>2、分类的编译的顺序</h4><ul>
<li>1）当分类与主类中都有同一个方法时，优先调用分类中的方法。</li>
<li>2）当多个分类中都有同样的一个方法时，优先调用最后一个参与编译的分类中的方法。</li>
</ul>
<h2 id="四、分类（Category）非正式协议"><a href="#四、分类（Category）非正式协议" class="headerlink" title="四、分类（Category）非正式协议"></a>四、分类（Category）非正式协议</h2><ul>
<li><p>显然这个名词是相对于正式协议而言的。在解释非正式协议之前,先引用两段话:</p>
</li>
<li><p>1、在《Cocoa设计模式》第六章类别的6.3.2把分类用于非正式协议一节中,这样写到:<code>非正式协议通常定义为NSObject的分类</code>。分类接口中指定的方法可能会或者可能不会被框架类实际地实现,而是被子类重写。</p>
</li>
<li><p>2、苹果官方文档Cocoa CoreCompetencies一文中是这样介绍非正式协议的:An informal protocol is a category on NSObject, which implicitly makes almost all objects adopters of the protocol. (A category is a language feature that enables you to add methods to a class without subclassing it.) Implementation of the methods in an informal protocol is optional. Before invoking a method, the calling object checks to see whether the target object implements it. Until optional protocol methods were introduced in Objective-C 2.0, informal protocols were essential to the way Foundation and AppKit classes implemented delegation.</p>
</li>
<li><p>大概意思:非正式协议是NSObject类(显而易见,还包括它的子类)的分类,其所有的子类都含蓄地接受了这个协议。(分类是Objective-C的一个语言特点,可以让你在无需子类化的前提下为一个类增加方法。)非正式协议中的方法是否实现都是可选的,因此在调用非正式协议中的方法之前,需要去检查对象类是否实现了它。在Objective-C2.0中引入可选的正式协议方法之前,非正式协议是Foundation和AppKit类实现委托的唯一方式。<br><code>所谓的非正式协议就是分类,即凡是NSObject或其子类Foundation框架中的类,增加的分类,都是非正式协议。</code></p>
</li>
<li><p>思考：</p>
<ul>
<li>统计一个字符串中数字的个数</li>
<li>NSString *s = @”dahfkd234234hkj324lk432bkb42”;</li>
</ul>
</li>
<li><p>解决方法：遍历字符串中的每个字符，判断是否在0-9之间。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">count</span>)</span></div><div class="line">-(<span class="keyword">void</span>)countStrNum;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">count</span>)</span></div><div class="line">-(<span class="keyword">void</span>)countStrNum</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//遍历字符串</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">self</span>.length;i++)</div><div class="line">&#123;</div><div class="line"><span class="comment">//获取字符串的每一个字符</span></div><div class="line"><span class="keyword">unichar</span> c = [<span class="keyword">self</span> characterAtIndex:i];</div><div class="line"></div><div class="line"><span class="comment">//判断是否是阿拉伯数字</span></div><div class="line"><span class="keyword">if</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//如果是阿拉伯数字,则+1</span></div><div class="line">count++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"count = %d"</span>,count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="五、分类（Catefory）延展"><a href="#五、分类（Catefory）延展" class="headerlink" title="五、分类（Catefory）延展"></a>五、分类（Catefory）延展</h2><h4 id="1、类的延展的概念"><a href="#1、类的延展的概念" class="headerlink" title="1、类的延展的概念"></a>1、类的延展的概念</h4><ul>
<li>延展类别又称为扩展(Extendsion)</li>
<li>Extension是Category的一个特例</li>
<li><p>其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制)</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> ()</span></div><div class="line">&#123;</div><div class="line">   <span class="comment">//类扩展 float value;</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">float</span>)newValue;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>这种写法的类别叫<code>匿名分类</code>,又叫<code>类扩展</code>,所谓的扩展,其实就是为一个类添加额外的原来没有的变量、方法或者合成属性。</p>
</li>
</ul>
<p>#####2、类扩展的作用：</p>
<ul>
<li>为本类扩充一些私有的成员变量和私有方法。</li>
</ul>
<h5 id="3、延展的实现"><a href="#3、延展的实现" class="headerlink" title="3、延展的实现"></a>3、延展的实现</h5><ul>
<li><p>1）通过延展来实现方法的私有,延展的头文件独立。这种方法不能实现真正的方法私有,当在别的文件中引入延展的头文件,那么在这个文件中定义的类的对象就可以直接调用在延展中定义所谓 私有的方法.</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对类的延展,隐藏方法的一种手段</span></div><div class="line">.h文件</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SceneManager</span> ()</span></div><div class="line">+ (<span class="keyword">void</span>) wrap;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">.m类的实现文件中</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SceneManager</span></span></div><div class="line">+ (<span class="keyword">void</span>) wrap &#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"method of wrap"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[SceneManager wrap];</div><div class="line"><span class="comment">// 这里会报一个警告:Class method of "+ wrap" not found</span></div><div class="line"><span class="comment">// 不过虽然是警告,不过运行是正常的,不过这么写在自我规范上不好,即使编译器没有做强制限制,我们自己也要限制自己。</span></div><div class="line"><span class="comment">// 不然,延展方法就毫无意义可言。</span></div></pre></td></tr></table></figure>
</li>
<li><p>2）第二种实现延展的方式是延展没有独立的头文件,在类的实现文件.m中声明和实现延展,这种方法可以很好的实现方法的私有,因为在OC中是不能引入.m的文件的。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> .m文件</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SceneManager</span> ()</span></div><div class="line">+ (<span class="keyword">void</span>) wrap;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SceneManager</span></span></div><div class="line">+ (<span class="keyword">void</span>) wrap &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"method of wrap"</span>); &#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">调用</div><div class="line">[SceneManager wrap];</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="分类和类扩展的区别："><a href="#分类和类扩展的区别：" class="headerlink" title="分类和类扩展的区别："></a>分类和类扩展的区别：</h5><ul>
<li>1、类别中只能增加方法;</li>
<li>2、是的,你没看错,类扩展不仅可以增加方法,还可以增加实例变量(或者合成属性),只是该<code>实例变量默认是私有类型的</code>(作用范围只能在自身类,而不是子类或其他地方);</li>
<li>3、类扩展中声明的方法没被实现,编译器会报警,但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中,而类别是在运行时添加到类中。</li>
<li>4、类扩展不能像类别那样拥有独立的实现部分(@implementation部分),也就是说,类扩展所声明的方法必须依托对应类的实现部分来实现。</li>
<li>5、定义在 .m 文件中的类扩展方法为私有的,定义在 .h 文件(头文件)中的类扩展方法为公有 的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/Protocol（协议）/" itemprop="url">
                  Protocol（协议）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T10:31:23+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Protocol概念及基本使用"><a href="#一、Protocol概念及基本使用" class="headerlink" title="一、Protocol概念及基本使用"></a>一、Protocol概念及基本使用</h2><h4 id="1、什么是Protocol"><a href="#1、什么是Protocol" class="headerlink" title="1、什么是Protocol?"></a>1、什么是Protocol?</h4><ul>
<li>1）Protocol中文意思：协议。</li>
<li>2）协议中只能声明一些方法。</li>
<li>3）遵守了协议，就等于拥有了协议中的所有方法。</li>
</ul>
<h4 id="2、协议的基本用法："><a href="#2、协议的基本用法：" class="headerlink" title="2、协议的基本用法："></a>2、协议的基本用法：</h4><ul>
<li><p>1、协议的定义格式：</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> 协议名称</span></div><div class="line"><span class="comment">// 各种方法；</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>2、协议的使用格式：</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> 类名 : <span class="title">NSObject</span> &lt;协议名1，协议名2，...&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、protocol类型限制"><a href="#二、protocol类型限制" class="headerlink" title="二、protocol类型限制"></a>二、protocol类型限制</h2><h4 id="1、protocol类型限制"><a href="#1、protocol类型限制" class="headerlink" title="1、protocol类型限制"></a>1、protocol类型限制</h4><h6 id="类型限制："><a href="#类型限制：" class="headerlink" title="类型限制："></a>类型限制：</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> d = [[Person alloc] init];</div><div class="line"></div><div class="line">要求：变量d指向的对象必须遵守PlayProtocol协议</div><div class="line"><span class="keyword">id</span>&lt;PlayProtocol&gt; d = [[Person alloc] init];</div><div class="line"></div><div class="line">要求：要求Person创建出来的对象，必须遵守PlayProtocol协议。</div><div class="line">Person &lt; PlayProtocol &gt; *p = [[Person alloc] init];</div><div class="line"></div><div class="line">真实使用场景:</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> :<span class="title">NSObject</span> &lt;<span class="title">PlayProtocol</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line">这样创建的任何对象，都拥有协议当中的方法。</div></pre></td></tr></table></figure>
<h4 id="2、id和instancetype的区别"><a href="#2、id和instancetype的区别" class="headerlink" title="2、id和instancetype的区别"></a>2、id和instancetype的区别</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">创建对象：</div><div class="line">(<span class="keyword">id</span>)person&#123;</div><div class="line">    <span class="keyword">return</span> [[Person alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">这样，子类无法用这个方法创建对象：</div><div class="line">(<span class="keyword">id</span>)person&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">调用自己没有的方法，程序会崩溃</div><div class="line">建议使用：</div><div class="line">(instanstype)person&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>id和instancetype的区别<ul>
<li>1）instancetype只能作为函数或者方法的返回值</li>
<li>2）id能作为方法或者参数的数据类型、返回值，也能用来定义变量。</li>
<li>3）instancetype对比id的好处：<ul>
<li>能精确的限制返回值的具体类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、protocol其他用法"><a href="#三、protocol其他用法" class="headerlink" title="三、protocol其他用法"></a>三、protocol其他用法</h2><h4 id="1、protocol的使用注意"><a href="#1、protocol的使用注意" class="headerlink" title="1、protocol的使用注意"></a>1、protocol的使用注意</h4><ul>
<li>1）把同一类方法，放到1个协议当中</li>
<li>2）1个类可以同时遵守多个协议。</li>
<li>3）父类遵守了某个协议，子类也遵守了该协议。</li>
<li>4）协议遵守协议：1个协议可以遵守多个协议。</li>
</ul>
<h4 id="2、protocol基协议介绍"><a href="#2、protocol基协议介绍" class="headerlink" title="2、protocol基协议介绍"></a>2、protocol基协议介绍</h4> <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SportProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"> * 此处的<span class="built_in">NSObject</span>就是基协议，意义等同于继承<span class="built_in">NSObject</span>。</div><div class="line"> * 继承基协议的好处：能够拥有基协议当中所声明的所有方法。</div></pre></td></tr></table></figure>
<ul>
<li>总结：</li>
<li>1、需要添加成员变量和方法时，建议使用继承</li>
<li>2、只需要添加方法时，建议使用分类</li>
<li>3、当很多不同类中，有共同的方法可以抽取时，类之间不存在继承关系，建议使用协议。</li>
</ul>
<h2 id="四、protocol中-required和-optional"><a href="#四、protocol中-required和-optional" class="headerlink" title="四、protocol中@required和@optional"></a>四、protocol中@required和@optional</h2><ul>
<li>@required：用@required修饰的方法，必须实现。</li>
<li>@optional：用@optional修饰的方法，可实现，可不实现。</li>
<li>@required 和 @optional的主要意义:一般用于序员交流用。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/13/autorelease/" itemprop="url">
                  autorelease
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-13T10:32:18+08:00" content="2016-07-13">
              2016-07-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、autorelease基本使用"><a href="#一、autorelease基本使用" class="headerlink" title="一、autorelease基本使用"></a>一、autorelease基本使用</h2><h4 id="1-自动释放池及autorelease介绍"><a href="#1-自动释放池及autorelease介绍" class="headerlink" title="1.自动释放池及autorelease介绍"></a>1.自动释放池及autorelease介绍</h4><ul>
<li><strong>1.自动释放池</strong><ul>
<li>(1)在iOS程序运行过程中,会创建无数个池子,这些池子都是以栈结构(先进后出)存在的。</li>
<li>(2)当一个对象调用autorelease时,会将这个对象放到位于栈顶的释放池中</li>
</ul>
</li>
<li><p><strong>2.自动释放池的创建方式</strong></p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)iOS <span class="number">5.0</span>以前的创建方式</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool=[[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    <span class="comment">// 代码</span></div><div class="line">    [pool release];  <span class="comment">//[pool drain];用于mac</span></div><div class="line">	</div><div class="line">(<span class="number">2</span>)iOS5<span class="number">.0</span>以后</div><div class="line"><span class="keyword">@autoreleasepool</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//开始代表创建自动释放池</span></div><div class="line">&#125; <span class="comment">//结束代表销毁自动释放池</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>3.autorelease</strong></p>
<ul>
<li>是一种支持引用计数的内存管理方式<ul>
<li>它可以暂时的保存某个对象(object),然后在内存池自己的排干(drain)的时候对其中的每个对象发送release消息。</li>
</ul>
</li>
<li>注意,这里只是发送release消息,如果当时的引用计数(reference-counted)依然不为0,则该对象依然不会被释放。可以用该方法来保存某个对象,也要注意保存之后要释放该对象。</li>
</ul>
</li>
</ul>
<h4 id="2、为什么会有autorelease？"><a href="#2、为什么会有autorelease？" class="headerlink" title="2、为什么会有autorelease？"></a>2、为什么会有autorelease？</h4><ul>
<li>OC的内存管理机制中比较重要的一条规律是:谁申请,谁释放<ul>
<li>考虑这种情况,如果一个方法需要返回一个新建的对象,该对象何时释放?</li>
<li>方法内部是不会写release来释放对象的,因为这样做会将对象立即释放而返回一个空对象;</li>
<li>调用者也不会主动释放该对象的,因为调用者遵循“谁申请,谁释放”的原则。那么这个时候,就发生了内存泄露。</li>
</ul>
</li>
<li>不使用autorelease存在的问题<ul>
<li>针对这种情况,Objective-C的设计了autorelease,既能确保对象能正确释放,又能返回有效的 对象。</li>
</ul>
</li>
<li>使用autorelease的好处<ul>
<li>(1)不需要再关心对象释放的时间</li>
<li>(2)不需要再关心什么时候调用release</li>
</ul>
</li>
</ul>
<p>####3.autorelease基本用法</p>
<ul>
<li><strong>基本用法</strong><ul>
<li>(1)会将对象放到一个自动释放池中</li>
<li>(2)当自动释放池被销毁时,会对池子里的所有对象做一次release</li>
<li>(3)会返回对象本身</li>
<li>(4)调用完autorelease方法后,对象的计数器不受影响(销毁时影响)</li>
<li>在autorelease的模式下,下述方法是合理的,即可以正确返回结果,也不会造成内存泄露。<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ClassA *Func1()</div><div class="line">&#123;</div><div class="line">  ClassA *obj = [[[ClassA alloc]init]autorelease];</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="4、autorelease的原理？"><a href="#4、autorelease的原理？" class="headerlink" title="4、autorelease的原理？"></a>4、autorelease的原理？</h4><ul>
<li>autorelease实际上只是把对release的调用延迟了,对于每一个Autorelease,系统只是把该Object放入了当前的Autorelease pool中,当该pool被释放时,该pool中的所有Object会被调用Release。</li>
</ul>
<h4 id="5、autorelease什么时候被释放？"><a href="#5、autorelease什么时候被释放？" class="headerlink" title="5、autorelease什么时候被释放？"></a>5、autorelease什么时候被释放？</h4><ul>
<li>对于autorelease pool本身,会在如下两个条件发生时候被释放<ul>
<li>1)手动释放Autorelease pool</li>
<li>2)Runloop结束后自动释放</li>
<li>对于autorelease pool内部的对象</li>
<li>在引用计数的retainCount ==0的时候释放。release和autorelease pool的 drain都会触发retain–事件。</li>
</ul>
</li>
</ul>
<h2 id="二、autorelease的应用场景"><a href="#二、autorelease的应用场景" class="headerlink" title="二、autorelease的应用场景"></a>二、autorelease的应用场景</h2><h4 id="1、autorelease的应用场景"><a href="#1、autorelease的应用场景" class="headerlink" title="1、autorelease的应用场景"></a>1、autorelease的应用场景</h4><ul>
<li><p>经常用来在类方法中快速创建1个对象。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明实现一个类方法</span></div><div class="line"> + (Student *)student</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 在里面直接进行autorelease</span></div><div class="line">    <span class="keyword">return</span> [[[Student alloc] init] autorelease];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>应用：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在自动释放池中使用类方法创建对象</span></div><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line"> <span class="comment">// 此时创建出来的对象不用关注释放问题。</span></div><div class="line">  Student *s = [Student student];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>错误写法：</p>
   <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line"><span class="comment">// 在自动释放池中使用类方法创建对象</span></div><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写在自动释放池外部将无法释放对象。</span></div><div class="line"> Student *s = [Student student];</div><div class="line"> reutrn <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、完善快速创建对象的方法"><a href="#2、完善快速创建对象的方法" class="headerlink" title="2、完善快速创建对象的方法"></a>2、完善快速创建对象的方法</h4><ul>
<li><p>问题1：如果定1个GoodStudent，继承自Student,此时，还能使用类方法快速创建对象吗？</p>
<ul>
<li><p>解决方案：</p>
<ul>
<li>在类方法中使用id</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   + (<span class="keyword">id</span>)student</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[[Student alloc] init] autorelease];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><code>此时，返回的对象仍旧是Student.所以，应该用self，替代Student.</code></p>
<ul>
<li>问题2：用其他对象类型，接受自定义对象类型。</li>
<li><p>如：</p>
<pre><code>NSString *s = [Student student];
NSLog(@&quot;%lu&quot;,s.length);
</code></pre><p><code>这段代码，编译时，不会报任何警告，但是运行时会直接崩溃。</code></p>
</li>
<li><p>改进办法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//instancetype：可以动态判断返回的类型和接受的类型是否一致</span></div><div class="line">  + (<span class="keyword">instancetype</span>)student&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时，编译器会警告</p>
<pre><code>NSString *s = [Student student];
NSLog(@&quot;%lu&quot;,s.length);
</code></pre></li>
</ul>
<h2 id="三、autorelease注意"><a href="#三、autorelease注意" class="headerlink" title="三、autorelease注意"></a>三、autorelease注意</h2><h4 id="1、autorelease使用注意"><a href="#1、autorelease使用注意" class="headerlink" title="1、autorelease使用注意"></a>1、autorelease使用注意</h4><h5 id="并不是放到自动释放池中，都会自动加入到自动释放池"><a href="#并不是放到自动释放池中，都会自动加入到自动释放池" class="headerlink" title="并不是放到自动释放池中，都会自动加入到自动释放池"></a>并不是放到自动释放池中，都会自动加入到自动释放池</h5><ul>
<li><p>1、因为没有调用autorelease方法，所以对象没有加入到自动释放池.</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">   <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">    Student *s = [[Student alloc] init];</div><div class="line">    [s release]; <span class="comment">// 正常释放</span></div><div class="line">   &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>2、在自动释放池的外部发送autorelease不会被加入到自动释放池中。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">   <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 发送autorelease消息的对象，放到制动释放池外部</span></div><div class="line">   <span class="comment">// 此时无法被自动释放</span></div><div class="line">  Student *s = [[[Student alloc] init] autorelease];</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>3、不管对象是在自动释放池里创建，还是自动释放池外创建，只要在自动释放池内写1个[s autorelease];s就会被放到自动释放池中，注意：autorelease是一个方法，且只有在自动释放池中使用才有效。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">     <span class="comment">// 不管在自动释放池内部还是外部创建</span></div><div class="line">     Student *s = [[Student alloc] init];</div><div class="line">     <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">         [s autorelease]; <span class="comment">// 此时s加入到释放池</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>2）自动释放池的嵌套使用</p>
<ul>
<li>自动释放池是栈结构。</li>
<li><p>栈：先进后出。后进先出，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">               <span class="comment">// 第一个池子，里面创建no的1学生</span></div><div class="line">                Student *s = [[[Student alloc] init] autorelease];</div><div class="line">                s.no = <span class="number">1</span>;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">                <span class="comment">// 第二个池子，里面创建no2的学生</span></div><div class="line">                   Student *s2 = [[[Student alloc] init] autorelease];</div><div class="line">                   s2.no = <span class="number">2</span>;</div><div class="line">            <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">                <span class="comment">// 第二个池子，里面创建no3的学生</span></div><div class="line">                        Student *s3 = [[[Student alloc] init] autorelease];</div><div class="line">                        s3.no = <span class="number">3</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>释放顺序：s3,s2,s1</p>
</li>
</ul>
</li>
<li>3）自动释放池中不适合放占用内存空间较大的对象<ul>
<li>1&gt; 尽量避免对大内存使用该方法，对于这种延迟释放机制，尽量少用</li>
<li>2&gt; 不要把大量循环操作放到同1个自动释放池中，这样会造成内存峰值的上升。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/12/内存管理/" itemprop="url">
                  内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-12T10:31:39+08:00" content="2016-07-12">
              2016-07-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、理解】内存管理的原则"><a href="#一、理解】内存管理的原则" class="headerlink" title="一、理解】内存管理的原则"></a>一、理解】内存管理的原则</h2><h4 id="1、内存管理的原则"><a href="#1、内存管理的原则" class="headerlink" title="1、内存管理的原则"></a>1、内存管理的原则</h4><ul>
<li>1.原则<ul>
<li>只要还有人在使用某个对象,那么这个对象就不会被回收;</li>
<li>只要你想使用这个对象,那么就应该让这个对象的引用计数器+1;</li>
<li>当你不想使用这个对象时,应该让对象的引用计数器-1;</li>
</ul>
</li>
<li>2.谁创建,谁release<ul>
<li>1)如果你通过alloc,new,copy来创建了一个对象,那么你就必须调用release或者 autorelease方法.</li>
<li>2)不是你创建的就不用你去负责</li>
</ul>
</li>
<li>3.谁retain,谁release<ul>
<li>只要你调用了retain,无论这个对象时如何生成的,你都要调用release</li>
</ul>
</li>
<li>4.总结<ul>
<li>有始有终,有加就应该有减。曾经让某个对象计数器加1,就应该让其在最后-1.</li>
</ul>
</li>
</ul>
<h4 id="2、内存管理研究内容"><a href="#2、内存管理研究内容" class="headerlink" title="2、内存管理研究内容"></a>2、内存管理研究内容</h4><ol>
<li>野指针(僵尸对象)<ul>
<li>僵尸对象: 已经被销毁的对象(不能再使用的对象).</li>
<li>野指针:指向僵尸对象(不可用内存)的指针.</li>
<li>空指针: 没有指向存储空间的指针(里面存的是nil, 也就是0)</li>
</ul>
</li>
<li><p>内存泄露</p>
<ul>
<li><p>如果在程序结束后，对象没有被释放，此时称为内存泄露。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Student *s = [[Student alloc] init];</div><div class="line">Student *s1 = [s <span class="keyword">retain</span>];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>那么，问题来了，最后由谁释放？</li>
<li><p>由s释放</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student *s = [[Student alloc] init];</div><div class="line">Student *s1 = [s <span class="keyword">retain</span>];</div><div class="line">[s release];</div><div class="line">[s release];</div></pre></td></tr></table></figure>
<ul>
<li><p>由s1释放</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student *s = [[Student alloc] init];</div><div class="line">Student *s1 = [s <span class="keyword">retain</span>];</div><div class="line">[s1 release];</div><div class="line">[s1 release];</div></pre></td></tr></table></figure>
</li>
<li><p>两种方式都可以释放内存。</p>
</li>
<li>但是，如果没有一种统一的释放原则，那么就会造成代码的混乱，舍都可以释放, 好比一个公司所有的领导没有分工一样, 任何事儿, 任何一个领导都可以插一嘴，很显然这样就没法干了， 因此需要有一个规范去约束使用。</li>
</ul>
</li>
</ul>
<h2 id="二、单个对象内存管理（野指针）"><a href="#二、单个对象内存管理（野指针）" class="headerlink" title="二、单个对象内存管理（野指针）"></a>二、单个对象内存管理（野指针）</h2><h4 id="1、单个对象的野指针问题"><a href="#1、单个对象的野指针问题" class="headerlink" title="1、单个对象的野指针问题"></a>1、单个对象的野指针问题</h4><ul>
<li><p>思考：对象在堆区的空间已经释放了,还能再使用p吗?</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *p = [[Person alloc] init];</div><div class="line">[p release];</div><div class="line"><span class="comment">// 因为P已经被释放，此时调用p的run方法，此时会报错。</span></div><div class="line"><span class="comment">// 我们把p叫做野指针，把p指向的对象叫做僵尸对象。</span></div><div class="line">[p run];</div></pre></td></tr></table></figure>
</li>
<li><p>野指针错误:访问了一块坏的内存(已经被回收的,不可用的内存)。</p>
</li>
<li>僵尸对象:所占内存已经被回收的对象,僵尸对象不能再被使用。(默认情况下xcode为了提高编码效率,不会时时检查僵尸对象,打开僵尸对象检测方法)</li>
<li><p>注意:</p>
<ul>
<li><p><strong>1–空指针:没有指向任何东西的指针,给空指针发送消息不会报错.</strong></p>
</li>
<li><p>关于nil和Nil及NULL的区别:</p>
<ul>
<li><p>1.nil: A null pointer to an Objective-C object. ( #define nil ((id)0) )</p>
<ul>
<li>nil 是一个对象值。</li>
<li>Person *p = [Person new];</li>
<li>p = nil;</li>
</ul>
</li>
<li><p>2.Nil: A null pointer to an Objective-C class.</p>
<ul>
<li>如:Class someClass = Nil;给类对象赋值</li>
</ul>
</li>
<li><p>3.NULL: A null pointer to anything else. ( #define NULL ((void *)0) )</p>
<ul>
<li>NULL是一个通用指针(泛型指针)。</li>
</ul>
</li>
<li><p>4.NSNull: A class defines a singleton object used to represent null values in collection objects (which don’t allow nil values).</p>
<ul>
<li>[NSNull null]: The singleton instance of NSNull。</li>
<li>[NSNull null]是一个对象,他用在不能使用nil的场合。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2–不能使用[p retain]让僵尸对象起死复生。</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="2、避免使用僵尸对象的方法"><a href="#2、避免使用僵尸对象的方法" class="headerlink" title="2、避免使用僵尸对象的方法"></a>2、避免使用僵尸对象的方法</h4><ul>
<li>为了防止不小心调用了僵尸对象,可以将对象赋值nil(对象的空值)</li>
<li><p>给空指针发消息是没有任何反应的。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  Student *s = [[Student alloc] init];</div><div class="line"></div><div class="line">  [s release];</div><div class="line"></div><div class="line">  s = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 打印对象的引用计数器值</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[s retainCount]);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、多个对象内存管理"><a href="#三、多个对象内存管理" class="headerlink" title="三、多个对象内存管理"></a>三、多个对象内存管理</h2><h5 id="解决方案：在使用房间时，对房间进行一次release。"><a href="#解决方案：在使用房间时，对房间进行一次release。" class="headerlink" title="解决方案：在使用房间时，对房间进行一次release。"></a>解决方案：在使用房间时，对房间进行一次release。</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明类</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Gamer</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    Room *_room;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room;</div><div class="line">- (Room *)room;</div><div class="line"></div><div class="line"><span class="comment">// 实现类</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Gamer</span></span></div><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room</div><div class="line">&#123;</div><div class="line"></div><div class="line">    [room <span class="keyword">retain</span>];</div><div class="line">    _room = room;</div><div class="line">&#125;</div><div class="line">- (Room *)room&#123;</div><div class="line">    <span class="keyword">return</span> _room;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"玩家被释放"</span>);</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// main函数实现</span></div><div class="line">  <span class="comment">// 1、创建玩家对象</span></div><div class="line">    Gamer *game = [[Gamer alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2、创建房间对象</span></div><div class="line">    Room *room = [[Room alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 3、让玩家进入房间</span></div><div class="line">    game.room = room;</div><div class="line"></div><div class="line">    <span class="comment">// 4、释放房间对象</span></div><div class="line">    [room release];</div><div class="line"></div><div class="line">    <span class="comment">// 5、输出玩家的房间</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"玩家的房间是：%@"</span>,game.room);</div></pre></td></tr></table></figure>
<ul>
<li><p>问题：房间无法被释放了怎么办？</p>
</li>
<li><p>解决方法：</p>
<ul>
<li><p>在对象被释放时，要把该对象的所有对象类型的成员变量在dealloc当中进行释放:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Gamer</span></span></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [_room release];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"玩家被释放"</span>);</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>需求：让玩家反复进入这个房间。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        Gamer *g = [Gamer new];</div><div class="line"></div><div class="line">        Room *r = [Room new];</div><div class="line"></div><div class="line">        g.room = r;</div><div class="line">        g.room = r;</div><div class="line">        g.room = r;</div><div class="line"></div><div class="line">        [g release];</div><div class="line">        [r release];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>问题：房间对象无法被释放，怎么办？</p>
</li>
<li><p>解决方案：判断新进房间与之前是否是同一个房间。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setRoom:(Room *)room</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_room != room) &#123;</div><div class="line">        [room <span class="keyword">retain</span>];</div><div class="line">        _room = room;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总的来说，有以下几点规律：</p>
<ul>
<li>1）只要还有人使用某对象，那么这个对象就不会被回收。</li>
<li>2）只要想要使用1个对象，那么就让对象的引用计数器+1。</li>
<li>3）当不再使用这个对象时，就让对象的引用计数器-1。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/block/" itemprop="url">
                  block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T10:32:18+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、block的概念及基本使用"><a href="#一、block的概念及基本使用" class="headerlink" title="一、block的概念及基本使用"></a>一、block的概念及基本使用</h2><h4 id="1、block的基本概念"><a href="#1、block的基本概念" class="headerlink" title="1、block的基本概念"></a>1、block的基本概念</h4><h5 id="1、什么是block？"><a href="#1、什么是block？" class="headerlink" title="1、什么是block？"></a>1、什么是block？</h5><ul>
<li>block是iOS中一种比较特殊的数据类型。</li>
<li>block是苹果官方特别推荐使用的数据类型，应用场景比较广泛。</li>
</ul>
<h5 id="2、使用场合？"><a href="#2、使用场合？" class="headerlink" title="2、使用场合？"></a>2、使用场合？</h5><pre><code>* 1）动画
* 2）多线程
* 3）集合遍历
* 4）网络请求回调
</code></pre><h5 id="3、block的作用"><a href="#3、block的作用" class="headerlink" title="3、block的作用"></a>3、block的作用</h5><pre><code>* 用来保存一段代码，可以在恰当的时间再取出来调用.
</code></pre><h4 id="2、block的基本用法"><a href="#2、block的基本用法" class="headerlink" title="2、block的基本用法"></a>2、block的基本用法</h4><h5 id="1）简单的认识下block"><a href="#1）简单的认识下block" class="headerlink" title="1）简单的认识下block"></a>1）简单的认识下block</h5><ul>
<li><p>函数写法：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">void</span> myBlock ()&#123;</div><div class="line">  <span class="built_in">NSLog</span>(@“******”);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>block写法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^myBlock)() =  ^&#123;</div><div class="line">  <span class="built_in">NSLog</span>(@“******”);</div><div class="line">&#125;；</div><div class="line">myBlock();</div></pre></td></tr></table></figure>
</li>
<li><p>block格式：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^block名称)(参数列表) = ^(参数列表)&#123;</div><div class="line"><span class="comment">// 代码实现；</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>block结构的快速提示：</p>
<pre><code>输入：inlineBlock
</code></pre></li>
</ul>
<h5 id="2）定义block遍历，存储一段代码，这段代码的功能是能打印任意行数"><a href="#2）定义block遍历，存储一段代码，这段代码的功能是能打印任意行数" class="headerlink" title="2）定义block遍历，存储一段代码，这段代码的功能是能打印任意行数"></a>2）定义block遍历，存储一段代码，这段代码的功能是能打印任意行数</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^ myBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> numberOfLines)&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfLines ; i ++)&#123;</div><div class="line">     <span class="built_in">NSLog</span>(@“******”);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="3）定义block，计算两个整数的和"><a href="#3）定义block，计算两个整数的和" class="headerlink" title="3）定义block，计算两个整数的和."></a>3）定义block，计算两个整数的和.</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^ sumBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)&#123;</div><div class="line">     <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> c = sumBlock(<span class="number">10</span>,<span class="number">20</span>);</div><div class="line"><span class="built_in">NSLog</span>(@“%d”,c);</div></pre></td></tr></table></figure>
<h5 id="4）定义1个block，计算1个整数的平方"><a href="#4）定义1个block，计算1个整数的平方" class="headerlink" title="4）定义1个block，计算1个整数的平方"></a>4）定义1个block，计算1个整数的平方</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^squareBlock)(<span class="keyword">int</span>);</div><div class="line">squareBlock = ^(<span class="keyword">int</span> sum)&#123;</div><div class="line">   <span class="keyword">return</span> sum * sum;</div><div class="line">&#125;;</div><div class="line">squareBlock(<span class="number">25</span>);</div></pre></td></tr></table></figure>
<h2 id="二、block的typedef"><a href="#二、block的typedef" class="headerlink" title="二、block的typedef"></a>二、block的typedef</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ( ^minusBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)&#123;</div><div class="line">  <span class="keyword">return</span> num1 - num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>定义1个叫做:MyBlock的数据类型，它存储的代码必须返回int，，必须接受2个int类型参数</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^MyBlock)(<span class="keyword">int</span>,<span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p>重命名之后，可这样使用：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyBlock minusBlock = ^(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)&#123;</div><div class="line">  <span class="keyword">return</span> num1 - num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、block访问外部变量"><a href="#三、block访问外部变量" class="headerlink" title="三、block访问外部变量"></a>三、block访问外部变量</h2><h4 id="1、block访问外面变量。"><a href="#1、block访问外面变量。" class="headerlink" title="1、block访问外面变量。"></a>1、block访问外面变量。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (^block()) = ^&#123;</div><div class="line">  <span class="built_in">NSLog</span>(@“%d”,a);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<h4 id="2、block修改外部变量值"><a href="#2、block修改外部变量值" class="headerlink" title="2、block修改外部变量值"></a>2、block修改外部变量值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (^block()) = ^&#123;</div><div class="line"> b = <span class="number">20</span>;</div><div class="line">  <span class="built_in">NSLog</span>(@“%d”,b);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<h4 id="3、block的快捷操作，名称写完整，直接敲回车"><a href="#3、block的快捷操作，名称写完整，直接敲回车" class="headerlink" title="3、block的快捷操作，名称写完整，直接敲回车."></a>3、block的快捷操作，名称写完整，直接敲回车.</h4><h2 id="四、block作为函数的返回值"><a href="#四、block作为函数的返回值" class="headerlink" title="四、block作为函数的返回值"></a>四、block作为函数的返回值</h2><h4 id="1、使用typedef定义一个新的类型"><a href="#1、使用typedef定义一个新的类型" class="headerlink" title="1、使用typedef定义一个新的类型"></a>1、使用typedef定义一个新的类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给block起一个别名</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^newType)(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2);</div></pre></td></tr></table></figure>
<h4 id="2、使用新类型作为函数的返回值"><a href="#2、使用新类型作为函数的返回值" class="headerlink" title="2、使用新类型作为函数的返回值"></a>2、使用新类型作为函数的返回值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个返回值是block类型的函数</span></div><div class="line">newType test()&#123;</div><div class="line"><span class="comment">//定义一个newType 类型的block变量</span></div><div class="line">newType work1=^(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> x+y;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> work1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、定义变量接收函数返回的值-block类型"><a href="#3、定义变量接收函数返回的值-block类型" class="headerlink" title="3、定义变量接收函数返回的值(block类型)"></a>3、定义变量接收函数返回的值(block类型)</h4><h4 id="4、调用block"><a href="#4、调用block" class="headerlink" title="4、调用block"></a>4、调用block</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在main函数中调用返回值是newType类型的函数</span></div><div class="line"></div><div class="line"><span class="comment">// 定义block类型的变量n</span></div><div class="line">newType n = test();</div><div class="line"></div><div class="line"><span class="comment">// 调用block，输出结果</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"n = %d"</span>,n(<span class="number">10</span>,<span class="number">20</span>));</div></pre></td></tr></table></figure>
<h2 id="五、应用：block的使用场景（一）"><a href="#五、应用：block的使用场景（一）" class="headerlink" title="五、应用：block的使用场景（一）"></a>五、应用：block的使用场景（一）</h2><h4 id="模拟上班场景"><a href="#模拟上班场景" class="headerlink" title="模拟上班场景"></a>模拟上班场景</h4><ul>
<li>用函数模拟周一~周五上班情景。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> goToWorkInDay1()&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 真正干的实事</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熟悉项目业务"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> goToWorkInDay2()&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 真正干的实事</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熟悉代码"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> goToWorkInDay3()&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 真正干的实事</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"编写代码"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>函数抽取</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 工作前做的事</span></div><div class="line"><span class="keyword">void</span> goToWorkPrefix()&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 工作后做的事</span></div><div class="line"><span class="keyword">void</span> goToWorkPSubfix()&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 第一天工作做的事</span></div><div class="line"><span class="keyword">void</span> goToWorkInDay1()&#123;</div><div class="line">   goToWorkPrefix()</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"了解项目需求"</span>);</div><div class="line">    goToWorkPSsubfix();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 第二天工作做的事</span></div><div class="line"><span class="keyword">void</span> goToWorkInDay1()&#123;</div><div class="line">   goToWorkPrefix()</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熟悉代码"</span>);</div><div class="line">    goToWorkPSsubfix();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.2）用函数抽取相同代码，提高复用性。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">void</span> goToWork(<span class="keyword">void</span> (^workBlock)())&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"goToWorkInDay%d"</span>,a);</div><div class="line">    a++;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 真正干的实事</span></div><div class="line"><span class="keyword">if</span> (workBlock != <span class="literal">nil</span>)&#123;</div><div class="line">    workBlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> goToWorkInDay1()&#123;</div><div class="line">  goToWork(^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"了解项目需求"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> goToWorkInDay2()&#123;</div><div class="line">    goToWork(^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"熟悉代码"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> goToWorkInDay3()&#123;</div><div class="line">    goToWork(^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"编写代码"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.3）使用block的注意事项：<ul>
<li>调用block时，不能传入空</li>
<li>如：</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>  main()&#123;</div><div class="line"> goToWork(<span class="literal">nil</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>1.4、使用循环语句抽取</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> preWork(<span class="keyword">void</span> (^workBlock)())&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"goToWorkInDay%d"</span>,a);</div><div class="line">    a++;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">    workBlock();</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> goToWork(<span class="keyword">int</span> day)&#123;</div><div class="line">    <span class="keyword">switch</span> (day) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            preWork(^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"熟悉项目业务"</span>);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            preWork(^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"熟悉代码"</span>);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">            preWork(^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"编写代码"</span>);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</div><div class="line">        goToWork(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="六、应用：block的使用场景（二）"><a href="#六、应用：block的使用场景（二）" class="headerlink" title="六、应用：block的使用场景（二）"></a>六、应用：block的使用场景（二）</h2><ul>
<li><strong>思考：用返回值是block的函数，修改我们应用场景的代码</strong></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 1、重命名block</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> (^workBlock)();</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">// 2、block作为返回值使用</span></div><div class="line">    workBlock workDay(<span class="keyword">int</span> d)&#123;</div><div class="line"></div><div class="line">   <span class="comment">// 拿到循环体中的block</span></div><div class="line">    workBlock work;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (d) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            <span class="comment">// 真正干的实事</span></div><div class="line">            work = ^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"熟悉项目代码"</span>);</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            <span class="comment">// 真正干的实事</span></div><div class="line">            work = (^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"熟悉项目代码"</span>);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">            <span class="comment">// 真正干的实事</span></div><div class="line">            work = (^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"编写代码"</span>);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">            <span class="comment">// 真正干的实事</span></div><div class="line">            work = (^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"扯淡"</span>);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">            <span class="comment">// 真正干的实事</span></div><div class="line">            work = (^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"聊天"</span>);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回循环体中的block内容</span></div><div class="line">    <span class="keyword">return</span> work;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3、修改工作日函数</span></div><div class="line"><span class="keyword">void</span> dayWork(<span class="keyword">int</span> d)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"起床"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"刷牙"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"穿衣服"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"出门"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抵达公司"</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 拿到重命名的block的返回值</span></div><div class="line">    workBlock work = workDay(d);</div><div class="line">    <span class="comment">// 调用block</span></div><div class="line">    work();</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下班"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"搭公交"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"回家"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"睡觉"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/10/NSFileManager介绍/" itemprop="url">
                  NSFileManager介绍和用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-10T10:32:18+08:00" content="2016-07-10">
              2016-07-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、NSFileManager介绍和用法"><a href="#一、NSFileManager介绍和用法" class="headerlink" title="一、NSFileManager介绍和用法"></a>一、NSFileManager介绍和用法</h2><h4 id="1、NSFileManager介绍"><a href="#1、NSFileManager介绍" class="headerlink" title="1、NSFileManager介绍"></a>1、NSFileManager介绍</h4><ul>
<li><strong>什么是NSFileManager？</strong><ul>
<li>顾名思义，NSFileManager是用来管理文件系统的。</li>
<li>它可以用来进行常见的文件、文件夹操作。</li>
<li>NSFileManager使用了单例模式</li>
<li>使用defaultManager方法可以获得那个单例对象<pre><code>[NSFileManager defaultManager]
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="2、NSFileManager用法（常见的判断）"><a href="#2、NSFileManager用法（常见的判断）" class="headerlink" title="2、NSFileManager用法（常见的判断）"></a>2、NSFileManager用法（常见的判断）</h4><h6 id="1、判断文件或者文件夹是否存在"><a href="#1、判断文件或者文件夹是否存在" class="headerlink" title="1、判断文件或者文件夹是否存在"></a>1、判断文件或者文件夹是否存在</h6><pre><code>-(BOOL)fileExistsAtPath:(NSString *)path;
</code></pre><h6 id="2、判断文件、文件夹是否存在，是否为文件夹"><a href="#2、判断文件、文件夹是否存在，是否为文件夹" class="headerlink" title="2、判断文件、文件夹是否存在，是否为文件夹"></a>2、判断文件、文件夹是否存在，是否为文件夹</h6><pre><code>-(BOOL)fileExistsAtPath:(NSString *)path isDirectory:(nullable BOOL *)isDirectory;
</code></pre><h6 id="3、path这个文件、文件夹是否可读"><a href="#3、path这个文件、文件夹是否可读" class="headerlink" title="3、path这个文件、文件夹是否可读"></a>3、path这个文件、文件夹是否可读</h6><pre><code>- (BOOL)isReadableFileAtPath:(NSString *)path;
</code></pre><h6 id="4、path这个文件、文件夹是否可写"><a href="#4、path这个文件、文件夹是否可写" class="headerlink" title="4、path这个文件、文件夹是否可写"></a>4、path这个文件、文件夹是否可写</h6><pre><code>- (BOOL)isWritableFileAtPath:(NSString *)path;
</code></pre><h6 id="5、path这个文件、文件夹是否可删除"><a href="#5、path这个文件、文件夹是否可删除" class="headerlink" title="5、path这个文件、文件夹是否可删除"></a>5、path这个文件、文件夹是否可删除</h6><pre><code>- (BOOL)isDeletableFileAtPath:(NSString *)path;
</code></pre><h6 id="6、path这个文件是否可执行（不常用）"><a href="#6、path这个文件是否可执行（不常用）" class="headerlink" title="6、path这个文件是否可执行（不常用）"></a>6、path这个文件是否可执行（不常用）</h6><pre><code>- (BOOL)isExecutableFileAtPath:(NSString *)path;
</code></pre><h6 id="7、案例："><a href="#7、案例：" class="headerlink" title="7、案例："></a>7、案例：</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1、判断文件或者文件夹是否存在</span></div><div class="line">  <span class="built_in">NSFileManager</span> *manage = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">  <span class="built_in">BOOL</span> exist = [manage fileExistsAtPath:<span class="string">@"/Users/sleepingsun/Desktop/工作"</span>];</div><div class="line">  </div><div class="line"><span class="comment">// 2、path这个文件、文件夹是否存在，isDirectory代表是否为文件夹</span></div><div class="line">   <span class="built_in">NSFileManager</span> *manage = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">   <span class="built_in">BOOL</span> dir = <span class="literal">NO</span>;</div><div class="line">   <span class="comment">// 后边判断时，可以通过dir的地址，去更改dir的值</span></div><div class="line">   <span class="built_in">BOOL</span> exist = [manage fileExistsAtPath:<span class="string">@"/Users/sleepingsun/Desktop/2.0.png"</span> isDirectory:&amp;dir];</div><div class="line">   </div><div class="line"><span class="comment">// 3、path这个文件、文件夹是否可读</span></div><div class="line">    <span class="comment">// 1、文件地址</span></div><div class="line">    <span class="built_in">NSString</span> *testPath = <span class="string">@"/Users/sleepingsun/Desktop/test"</span>;</div><div class="line">    <span class="comment">// 2、获得文件管理者</span></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="comment">// 3、判断文件夹是否可读</span></div><div class="line">    <span class="built_in">BOOL</span> temp = [fileManager isReadableFileAtPath:testPath];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件是否可读：%d"</span>,temp);</div><div class="line">    </div><div class="line"><span class="comment">// 4、path这个文件、文件夹是否可写</span></div><div class="line">    <span class="comment">// 1、文件地址</span></div><div class="line">    <span class="built_in">NSString</span> *testPath = <span class="string">@"/Users/sleepingsun/Desktop/test"</span>;</div><div class="line">    <span class="comment">// 2、获得文件管理者</span></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="comment">// 3、判断文件夹是否可写</span></div><div class="line">    <span class="built_in">BOOL</span> temp = [fileManager isWritableFileAtPath:testPath];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件是否可写：%d"</span>,temp);</div><div class="line"></div><div class="line"><span class="comment">// 5、path这个文件、文件夹是否可删除</span></div><div class="line">- (<span class="built_in">BOOL</span>)isDeletableFileAtPath:(<span class="built_in">NSString</span> *)path;</div><div class="line"></div><div class="line"><span class="comment">// 6、path这个文件是否可执行（不常用）</span></div><div class="line">- (<span class="built_in">BOOL</span>)isExecutableFileAtPath:(<span class="built_in">NSString</span> *)path;</div><div class="line"></div><div class="line">```      </div><div class="line">       </div><div class="line"><span class="meta">## 二、NSFileManager的文件访问</span></div><div class="line"></div><div class="line"><span class="meta">#### 1、获得文件、文件夹的属性</span></div><div class="line">```objc</div><div class="line">    <span class="comment">// 获取文件或者文件夹属性用法</span></div><div class="line">    - (<span class="built_in">NSDictionary</span> *)attributesOfItemAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error;</div><div class="line">    <span class="comment">// 1、文件地址</span></div><div class="line">    <span class="built_in">NSString</span> *testPath = <span class="string">@"/Users/sleepingsun/Desktop/test"</span>;</div><div class="line">    <span class="comment">// 2、获得文件管理者</span></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="comment">// 3、获取文件属性</span></div><div class="line">    <span class="built_in">NSDictionary</span> *dic = [fileManager attributesOfItemAtPath:testPath error:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic);</div></pre></td></tr></table></figure>
<h4 id="2、获得某个文件夹下得所有子路径"><a href="#2、获得某个文件夹下得所有子路径" class="headerlink" title="2、获得某个文件夹下得所有子路径"></a>2、获得某个文件夹下得所有子路径</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)subpathsAtPath:(<span class="built_in">NSString</span> *)path;</div><div class="line">- (<span class="built_in">NSArray</span> *)subpathsOfDirectoryAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<h4 id="3、获得某个文件夹的当前子路径"><a href="#3、获得某个文件夹的当前子路径" class="headerlink" title="3、获得某个文件夹的当前子路径"></a>3、获得某个文件夹的当前子路径</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)contentsOfDirectoryAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<h4 id="4、获得文件内容"><a href="#4、获得文件内容" class="headerlink" title="4、获得文件内容"></a>4、获得文件内容</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSData</span> *)contentsAtPath:(<span class="built_in">NSString</span> *)path;</div></pre></td></tr></table></figure>
<h2 id="三、NSFileManager的文件或文件夹操作"><a href="#三、NSFileManager的文件或文件夹操作" class="headerlink" title="三、NSFileManager的文件或文件夹操作"></a>三、NSFileManager的文件或文件夹操作</h2><p>####1、创建文件夹：<br>创建文件夹(createIntermediates为YES代表自动创建中间的文件夹)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)createDirectoryAtPath:(<span class="built_in">NSString</span> *)path withIntermediateDirectories:(<span class="built_in">BOOL</span>)createIntermediates attributes:(<span class="built_in">NSDictionary</span> *)attributes error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<p>案例:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1、创建文件夹的根路径</span></div><div class="line"><span class="built_in">NSString</span> *documentsPath = <span class="string">@"/Users/sleepingsun/Desktop/"</span>;</div><div class="line"><span class="comment">// 2、在根目录基础上，拼接要创建的文件夹名称</span></div><div class="line"><span class="built_in">NSString</span> *testDirectory = [documentsPath stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line"><span class="comment">// 3、获得文件管理者</span></div><div class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line"><span class="comment">/*</span></div><div class="line">4、创建文件夹</div><div class="line">1）第一个参数：创建文件夹的具体地址</div><div class="line">2）第二个参数：是否创建中间临时文件夹</div><div class="line">   YES：连续创建文件夹</div><div class="line">   NO ：如果有多个路径，中间文件夹不会自动生成，会创建失败。</div><div class="line">3）第三个参数：属性，默认选择nil</div><div class="line">4）没创建成功，返回的错误，此时选择nil</div><div class="line">*/</div><div class="line"><span class="built_in">BOOL</span> res = [fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"><span class="comment">// 5、判断文件夹是否创建成功</span></div><div class="line"><span class="keyword">if</span> (res) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件夹创建成功"</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"文件夹创建失败"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2、创建文件"><a href="#2、创建文件" class="headerlink" title="2、创建文件"></a>2、创建文件</h4><p>NSData是用来存储二进制字节数据的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)createFileAtPath:(<span class="built_in">NSString</span> *)path contents:(<span class="built_in">NSData</span> *)data attributes:(<span class="built_in">NSDictionary</span> *)attr;</div></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 创建文件</span></div><div class="line">    <span class="comment">// 1、创建文件夹的根路径</span></div><div class="line">    <span class="built_in">NSString</span> *documentsPath = <span class="string">@"/Users/sleepingsun/Desktop/"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 2、在根目录基础上，拼接要创建的文件夹名称</span></div><div class="line">    <span class="built_in">NSString</span> *testDirectory = [documentsPath stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 3、在已有文件夹的基础上，拼接文件名</span></div><div class="line">    <span class="built_in">NSString</span> *testPath = [testDirectory stringByAppendingPathComponent:<span class="string">@"test.txt"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 4、获取文件管理者</span></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line"></div><div class="line">    <span class="comment">// 5、创建文件</span></div><div class="line">    <span class="comment">// 1）内容：此处默认nil</span></div><div class="line">    <span class="comment">// 2）属性：默认nil</span></div><div class="line">    <span class="built_in">BOOL</span> res = [fileManager createFileAtPath:testPath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</div><div class="line">        <span class="keyword">if</span> (res) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"文件创建成功: %@"</span> ,testPath);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"文件创建失败"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//写文件</span></div><div class="line">    <span class="built_in">NSString</span> *documentsPath = <span class="string">@"/Users/sleepingsun/Desktop/"</span>;</div><div class="line">    <span class="built_in">NSString</span> *testDirectory = [documentsPath stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line">    <span class="built_in">NSString</span> *testPath = [testDirectory stringByAppendingPathComponent:<span class="string">@"test.txt"</span>];</div><div class="line">    <span class="built_in">NSString</span> *content=<span class="string">@"测试写入内容！"</span>;</div><div class="line">    <span class="built_in">BOOL</span> res=[content writeToFile:testPath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">if</span> (res) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"文件写入成功"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"文件写入失败"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 读文件</span></div><div class="line">    <span class="built_in">NSString</span> *documentsPath = <span class="string">@"/Users/sleepingsun/Desktop/"</span>;</div><div class="line">    <span class="built_in">NSString</span> *testDirectory = [documentsPath stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line">    <span class="built_in">NSString</span> *testPath = [testDirectory stringByAppendingPathComponent:<span class="string">@"test.txt"</span>];</div><div class="line"><span class="comment">//    NSData *data = [NSData dataWithContentsOfFile:testPath];</span></div><div class="line"><span class="comment">//    NSLog(@"文件读取成功: %@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span></div><div class="line">    <span class="built_in">NSString</span> *content=[<span class="built_in">NSString</span> stringWithContentsOfFile:testPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件读取成功: %@"</span>,content);</div></pre></td></tr></table></figure>
<h4 id="3、删除文件"><a href="#3、删除文件" class="headerlink" title="3、删除文件"></a>3、删除文件</h4><p>案例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除文件</span></div><div class="line"><span class="comment">// 1、根目录</span></div><div class="line"><span class="built_in">NSString</span> *documentsPath = <span class="string">@"/Users/sleepingsun/Desktop/"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 2、在根目录后边拼接文件夹名称</span></div><div class="line"><span class="built_in">NSString</span> *testDirectory = [documentsPath stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 3、在文件夹目录后边拼接文件名称</span></div><div class="line"><span class="built_in">NSString</span> *testPath = [testDirectory stringByAppendingPathComponent:<span class="string">@"test.txt"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 4、获得文件管理者</span></div><div class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line"></div><div class="line"><span class="comment">// 5、用文件管理者删除指定路径的文件</span></div><div class="line"><span class="built_in">BOOL</span> res=[fileManager removeItemAtPath:testPath error:<span class="literal">nil</span>];</div><div class="line"><span class="keyword">if</span> (res) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件删除成功"</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件删除失败"</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"文件是否存在: %@"</span>,[fileManager isExecutableFileAtPath:testPath]?<span class="string">@"YES"</span>:<span class="string">@"NO"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4、拷贝-移动-删除"><a href="#4、拷贝-移动-删除" class="headerlink" title="4、拷贝/移动/删除"></a>4、拷贝/移动/删除</h4><p>拷贝</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)copyItemAtPath:(<span class="built_in">NSString</span> *)srcPath toPath:(<span class="built_in">NSString</span> *)dstPath error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<p>移动(剪切)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)moveItemAtPath:(<span class="built_in">NSString</span> *)srcPath toPath:(<span class="built_in">NSString</span> *)dstPath error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)removeItemAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/09/UITextField/" itemprop="url">
                  UITextField
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-09T16:20:33+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、UITextField属性"><a href="#一、UITextField属性" class="headerlink" title="一、UITextField属性"></a>一、UITextField属性</h1><p>设置和获取文字框文字<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *text;</div></pre></td></tr></table></figure></p>
<p>通过AttributedString创建和获取文字<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *attributedText；</div></pre></td></tr></table></figure></p>
<p>设置字体颜色属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIColor</span> *textColor;</div></pre></td></tr></table></figure></p>
<p>设置字体属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIFont</span> *font;</div></pre></td></tr></table></figure></p>
<p>设置字体对齐格式<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">NSTextAlignment</span> textAlignment;</div></pre></td></tr></table></figure></p>
<p>设置输入框风格<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextBorderStyle</span> borderStyle;</div><div class="line"></div><div class="line"><span class="built_in">UITextBorderStyleNone</span>,			<span class="comment">//没有任何边框</span></div><div class="line"><span class="built_in">UITextBorderStyleLine</span>,			<span class="comment">//线性边框</span></div><div class="line"><span class="built_in">UITextBorderStyleBezel</span>,			<span class="comment">//阴影效果边框</span></div><div class="line"><span class="built_in">UITextBorderStyleRoundedRect</span>	<span class="comment">//原型效果边框</span></div></pre></td></tr></table></figure></p>
<p>设置默认字体属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *defaultTextAttributes；</div></pre></td></tr></table></figure></p>
<p><strong>注：这个属性的设置会影响到全部字体的属性。</strong><br>设置占位图片<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *placeholder;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *attributedPlaceholder；</div></pre></td></tr></table></figure></p>
<p>设置是否在开始编辑时清空输入框内容<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> clearsOnBeginEditing;</div></pre></td></tr></table></figure></p>
<p>设置字体大小是否随宽度自适应（默认为NO）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> adjustsFontSizeToFitWidth;</div></pre></td></tr></table></figure></p>
<p>设置最小字体大小<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> minimumFontSize;</div></pre></td></tr></table></figure></p>
<p>设置背景图片（会被拉伸）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIImage</span> *background;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIImage</span> *disabledBackground;</div></pre></td></tr></table></figure></p>
<p>设置清除按钮的显示模式<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextFieldViewMode</span> clearButtonMode;</div><div class="line"></div><div class="line"><span class="built_in">UITextFieldViewModeNever</span>,			<span class="comment">//从不显示</span></div><div class="line"><span class="built_in">UITextFieldViewModeWhileEditing</span>,	<span class="comment">//编辑的时候显示</span></div><div class="line"><span class="built_in">UITextFieldViewModeUnlessEditing</span>,	<span class="comment">//非编辑的时候显示</span></div><div class="line"><span class="built_in">UITextFieldViewModeAlways</span>			<span class="comment">//任何时候都显示</span></div></pre></td></tr></table></figure></p>
<p>设置输入框左/右边的view<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span> *leftView;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span> *rightView;</div></pre></td></tr></table></figure></p>
<p>设置输入框左/右视图的显示模式<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextFieldViewMode</span> leftViewMode;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UITextFieldViewMode</span> rightViewMode;</div></pre></td></tr></table></figure></p>
<p>设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">retain</span>) <span class="built_in">UIView</span> *inputView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">retain</span>) <span class="built_in">UIView</span> *inputAccessoryView;</div></pre></td></tr></table></figure></p>
<p>这个属性设置是否允许再次编辑时在内容中间插入内容<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> clearsOnInsertion；</div></pre></td></tr></table></figure></p>
<p>密码文本框是暗文(UITextInputTraits)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isSecureTextEntry) <span class="built_in">BOOL</span> secureTextEntry;</div></pre></td></tr></table></figure></p>
<h3 id="补充三个不常用方法（UIKeyInput）"><a href="#补充三个不常用方法（UIKeyInput）" class="headerlink" title="补充三个不常用方法（UIKeyInput）"></a>补充三个不常用方法（UIKeyInput）</h3><p>判断UITextField当前是否有内容<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)hasText;</div></pre></td></tr></table></figure></p>
<p>从键盘输入内容就会调用此方法（中文无效）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)insertText:(<span class="built_in">NSString</span> *)text;</div></pre></td></tr></table></figure></p>
<p>当击UITextField右边大删除按钮<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deleteBackward;</div></pre></td></tr></table></figure></p>
<h1 id="二、UITextField-设置监听的3种方式"><a href="#二、UITextField-设置监听的3种方式" class="headerlink" title="二、UITextField 设置监听的3种方式:"></a>二、UITextField 设置监听的3种方式:</h1><h3 id="1、通过addTarget方式"><a href="#1、通过addTarget方式" class="headerlink" title="1、通过addTarget方式"></a>1、通过addTarget方式</h3><ul>
<li>UITextField继承UIControll,可以addTarget监听。</li>
<li>但是这种方式只能监听一些”单击事件”、”滚动条滚动事件”等, 有些事件通过addTarget方式监听无效, 比如”Value Changed”事件。</li>
</ul>
<h3 id="2、通过代理"><a href="#2、通过代理" class="headerlink" title="2、通过代理"></a>2、通过代理</h3><ul>
<li>文本框的代理协议”UITextFieldDelegate”。</li>
<li>演示:textFieldShouldBeginEditing方法。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为某个文本框设置代理</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 设置文本框代理为当前控制器。</span></div><div class="line">    <span class="keyword">self</span>.textFidld.delegate = <span class="keyword">self</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 让当前控制器遵守UITextFieldDelegate协议, 并且实现- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField方法, 返回YES</span></div><div class="line">- (<span class="built_in">BOOL</span>)textFieldShouldBeginEditing:(<span class="built_in">UITextField</span> *)textField</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、通过”通知中心”监听事件。"><a href="#3、通过”通知中心”监听事件。" class="headerlink" title="3、通过”通知中心”监听事件。"></a>3、通过”通知中心”监听事件。</h3><p><strong> 思路: 让用户名、密码文本框同时设置监听到textChanged方法。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参考代码:</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"><span class="comment">//通过通知中心监听文本框内容变化, 添加观察者</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(textFieldValueChanged) name:<span class="built_in">UITextFieldTextDidChangeNotification</span> object:<span class="keyword">self</span>.userNameTextField];</div><div class="line"></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(textFieldValueChanged) name:<span class="built_in">UITextFieldTextDidChangeNotification</span> object:<span class="keyword">self</span>.passWordTextField];</div><div class="line"></div><div class="line"><span class="comment">//TextField通知名</span></div><div class="line"><span class="comment">//    UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;</span></div><div class="line"><span class="comment">//    UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;</span></div><div class="line"><span class="comment">//    UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//实现监听方法</span></div><div class="line">- (<span class="keyword">void</span>) textFieldValueChanged</div><div class="line">&#123;</div><div class="line">    <span class="comment">//文本框的值发送改变, 就会调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**** 注意通过通知的方式注册事件, 需要在dealloc方法中移除 ****/</span></div><div class="line"><span class="comment">// 移除通知监听, 观察者被销毁时, 在观察着的dealloc方法中移除</span></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">//移除观察者</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、Segue对象。"><a href="#4、Segue对象。" class="headerlink" title="4、Segue对象。"></a>4、Segue对象。</h3><ul>
<li><p>在xcode6.1下, 拖线时选择Segue的style为show, 等价于以前的push。</p>
</li>
<li><p>重新拖线（手动 Segue）, 从控制器 to 控制器。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参考代码 :</span></div><div class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"login2contact"</span> sender:<span class="string">@"Jack"</span>];</div><div class="line"></div><div class="line"><span class="comment">//实现控制器的- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender方法。</span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender &#123;</div><div class="line"><span class="comment">// Get the new view controller using [segue destinationViewController].</span></div><div class="line"><span class="comment">// Pass the selected object to the new view controller.</span></div><div class="line"><span class="comment">//    NSLog(@"%@",sender);</span></div><div class="line"><span class="comment">//获取目标控制器</span></div><div class="line">    <span class="built_in">UIViewController</span> * targetVC = segue.destinationViewController;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//performSegueWithIdentifier:sender:的执行过程</span></div><div class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"login2contacts"</span> sender:<span class="literal">nil</span>];</div><div class="line"><span class="comment">//1&gt; self是来源控制器，只能通过来源控制器来调该方法。</span></div><div class="line"><span class="comment">//2&gt; 根据identifier去storyboard中找到对应的线，新建UIStoryboardSegue对象</span></div><div class="line"><span class="comment">//3&gt; 设置Segue对象的sourceViewController（来源控制器）</span></div><div class="line"><span class="comment">//4&gt; 新建并且设置Segue对象的destinationViewController（目标控制器）</span></div><div class="line"><span class="comment">//5&gt; 调用- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender方法</span></div><div class="line"><span class="comment">//6&gt; 执行跳转。</span></div><div class="line"><span class="comment">//** 具体跳转步骤:</span></div><div class="line"><span class="comment">//1&gt; 通过segue对象的sourceViewController获取源控制器所在的导航控制器。</span></div><div class="line"><span class="comment">//2&gt; 将segue的destinationViewControlelr压栈(push)进去。</span></div></pre></td></tr></table></figure>
<h3 id="5、提示框的弹出"><a href="#5、提示框的弹出" class="headerlink" title="5、提示框的弹出"></a>5、提示框的弹出</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//xcode7下</span></div><div class="line">- (<span class="keyword">IBAction</span>)logOutBtnClick:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIAlertController</span> * alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"确定注销吗?"</span> message:<span class="literal">nil</span> preferredStyle:<span class="built_in">UIAlertControllerStyleActionSheet</span>];</div><div class="line"></div><div class="line">    <span class="built_in">UIAlertAction</span> * okAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</div><div class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="built_in">UIAlertAction</span> * cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    [alert addAction:okAction];</div><div class="line"></div><div class="line">    [alert addAction:cancel];</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xcode6</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 弹出UIActionSheet对话框</span></div><div class="line"><span class="built_in">UIActionSheet</span> *sheet = [[<span class="built_in">UIActionSheet</span> alloc] initWithTitle:<span class="string">@"确定要注销"</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"取消"</span> destructiveButtonTitle:<span class="string">@"注销"</span> otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">//alertView 上添加一个 textField</span></div><div class="line"><span class="comment">/*</span></div><div class="line">UIAlertViewStyleDefault = 0,</div><div class="line">UIAlertViewStyleSecureTextInput,//安全的文本输入, 密码保护模式</div><div class="line">UIAlertViewStylePlainTextInput,//普通的文本输入</div><div class="line">UIAlertViewStyleLoginAndPasswordInput//两行输入,Login 和 Password</div><div class="line">*/</div><div class="line">alertView.alertViewStyle = <span class="built_in">UIAlertViewStylePlainTextInput</span>;</div><div class="line"></div><div class="line"><span class="comment">//获取 alertView上的 textField</span></div><div class="line"><span class="built_in">UITextField</span> *textField = [alertView textFieldAtIndex:<span class="number">0</span>];</div><div class="line"></div><div class="line">[sheet showInView:<span class="keyword">self</span>.view];</div></pre></td></tr></table></figure>
<ul>
<li>UIActionSheet中的按钮点击事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)actionSheet:(<span class="built_in">UIActionSheet</span> *)actionSheet clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</div><div class="line">&#123;</div><div class="line">    <span class="comment">//buttonIndex 对应按钮的下标</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="awakeFromNib"><a href="#awakeFromNib" class="headerlink" title="awakeFromNib"></a>awakeFromNib</h3><ul>
<li>awakeFromNib什么时候调用？xib加载完成的时候调用</li>
<li>awakeFromNib的作用:从控件从xib加载完成之后，做一些初始化操作。</li>
<li>在layoutSubViews设置尺寸。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/09/NSDate的介绍/" itemprop="url">
                  NSDate的介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-09T10:32:18+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、NSDate的介绍"><a href="#一、NSDate的介绍" class="headerlink" title="一、NSDate的介绍"></a>一、NSDate的介绍</h2><h4 id="1、【理解】NSDate的介绍和使用"><a href="#1、【理解】NSDate的介绍和使用" class="headerlink" title="1、【理解】NSDate的介绍和使用"></a>1、【理解】NSDate的介绍和使用</h4><ul>
<li>NSDate可以用来表示时间,可以进行一些常见的日期\时间处理。</li>
<li>一个NSDate对象就代表一个时间</li>
</ul>
<h4 id="2、格式化日期"><a href="#2、格式化日期" class="headerlink" title="2、格式化日期"></a>2、格式化日期</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">formatter.dateFormat = @&quot;yyyy-MM-dd HH:mm:ss&quot;;</div><div class="line"></div><div class="line">// 将NSString转换为NSDate</div><div class="line">NSDate *date = [formatter dateFromString:@&quot;2010-03-24 00:00:00&quot;];</div><div class="line"></div><div class="line">// 将NSDate转换为NSString</div><div class="line">NSLog(@&quot;%@&quot;, [formatter stringFromDate:date]);</div></pre></td></tr></table></figure>
<h4 id="3、计算日期"><a href="#3、计算日期" class="headerlink" title="3、计算日期"></a>3、计算日期</h4><ul>
<li>[NSDate date]返回的就是当前时间</li>
</ul>
<h4 id="4、日期时间对象"><a href="#4、日期时间对象" class="headerlink" title="4、日期时间对象"></a>4、日期时间对象</h4><ul>
<li>结合NSCalendar和NSDate能做更多的日期\时间处理</li>
<li><p>获得NSCalendar对象</p>
<pre><code>NSCalendar *calendar = [NSCalendar currentCalendar];
</code></pre></li>
<li><p>获得年月日</p>
<pre><code>- (NSDateComponents *)components:(NSCalendarUnit)unitFlags fromDate:(NSDate *)date;
</code></pre></li>
<li><p>比较两个日期的差距</p>
<pre><code>- (NSDateComponents *)components:(NSCalendarUnit)unitFlags fromDate:(NSDate *)startingDate toDate:(NSDate *)resultDate options:(NSCalendarOptions)opts;
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/09/SQLite语句/" itemprop="url">
                  SQLite语句
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-09T10:31:23+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/提高篇/" itemprop="url" rel="index">
                    <span itemprop="name">提高篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h4 id="1、SQL语句的特点"><a href="#1、SQL语句的特点" class="headerlink" title="1、SQL语句的特点"></a>1、SQL语句的特点</h4><ul>
<li>不区分大小写（比如数据库认为user和UsEr是一样的）</li>
<li>每条语句都必须以分号 ; 结尾</li>
</ul>
<h6 id="SQL中的常用关键字有"><a href="#SQL中的常用关键字有" class="headerlink" title="SQL中的常用关键字有"></a>SQL中的常用关键字有</h6><p>select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index等等</p>
<p><strong>数据库中不可以使用关键字来命名表、字段</strong></p>
<h4 id="2、SQL语句的种类"><a href="#2、SQL语句的种类" class="headerlink" title="2、SQL语句的种类"></a>2、SQL语句的种类</h4><h6 id="数据定义语句（DDL：Data-Definition-Language）"><a href="#数据定义语句（DDL：Data-Definition-Language）" class="headerlink" title="数据定义语句（DDL：Data Definition Language）"></a>数据定义语句（DDL：Data Definition Language）</h6><ul>
<li>包括create和drop等操作</li>
<li>在数据库中创建新表或删除表（create table或 drop table）<h6 id="数据操作语句（DML：Data-Manipulation-Language）"><a href="#数据操作语句（DML：Data-Manipulation-Language）" class="headerlink" title="数据操作语句（DML：Data Manipulation Language）"></a>数据操作语句（DML：Data Manipulation Language）</h6></li>
<li>包括insert、update、delete等操作</li>
<li>上面的3种操作分别用于添加、修改、删除表中的数据<h6 id="数据查询语句（DQL：Data-Query-Language）"><a href="#数据查询语句（DQL：Data-Query-Language）" class="headerlink" title="数据查询语句（DQL：Data Query Language）"></a>数据查询语句（DQL：Data Query Language）</h6></li>
<li>可以用于查询获得表中的数据</li>
<li>关键字select是DQL（也是所有SQL）用得最多的操作</li>
<li>其他DQL常用的关键字有where，order by，group by和having</li>
</ul>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h4 id="1、创表"><a href="#1、创表" class="headerlink" title="1、创表"></a>1、创表</h4><h6 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h6><ul>
<li>create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;</li>
<li>create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;</li>
</ul>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><ul>
<li>create table t_student (id integer, name text, age inetger, score real) ;</li>
</ul>
<h4 id="2、字段类型"><a href="#2、字段类型" class="headerlink" title="2、字段类型"></a>2、字段类型</h4><h6 id="SQLite将数据划分为以下几种存储类型："><a href="#SQLite将数据划分为以下几种存储类型：" class="headerlink" title="SQLite将数据划分为以下几种存储类型："></a>SQLite将数据划分为以下几种存储类型：</h6><ul>
<li>integer : 整型值</li>
<li>real : 浮点值</li>
<li>text : 文本字符串</li>
<li>blob : 二进制数据（比如文件）</li>
</ul>
<h6 id="实际上SQLite是无类型的"><a href="#实际上SQLite是无类型的" class="headerlink" title="实际上SQLite是无类型的"></a>实际上SQLite是无类型的</h6><ul>
<li>就算声明为integer类型，还是能存储字符串文本（主键除外）</li>
<li>建表时声明啥类型或者不声明类型都可以，也就意味着创表语句可以这么写：</li>
<li>create table t_student(name, age);</li>
</ul>
<p><strong>为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型</strong></p>
<h4 id="3、删表"><a href="#3、删表" class="headerlink" title="3、删表"></a>3、删表</h4><h6 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h6><ul>
<li>drop table 表名 ;</li>
<li>drop table if exists 表名 ;<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6></li>
<li>drop table t_student ;</li>
</ul>
<h4 id="4、插入数据（insert）"><a href="#4、插入数据（insert）" class="headerlink" title="4、插入数据（insert）"></a>4、插入数据（insert）</h4><h6 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h6><ul>
<li>insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …) ;</li>
</ul>
<h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><ul>
<li>insert into t_student (name, age) values (‘lnj’, 10) ;</li>
</ul>
<p><strong>注：数据库中的字符串内容应该用单引号 ’ 括住</strong></p>
<h4 id="5、更新数据（update）"><a href="#5、更新数据（update）" class="headerlink" title="5、更新数据（update）"></a>5、更新数据（update）</h4><h6 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h6><ul>
<li>update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ; </li>
</ul>
<h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><ul>
<li>update t_student set name = ‘jack’, age = 20 ; </li>
</ul>
<p><strong>注：上面的示例会将t_student表中所有记录的name都改为jack，age都改为20</strong></p>
<h4 id="6、删除数据（delete）"><a href="#6、删除数据（delete）" class="headerlink" title="6、删除数据（delete）"></a>6、删除数据（delete）</h4><h6 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a>格式</h6><ul>
<li>delete from 表名 ;</li>
</ul>
<h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><p>delete from t_student ;</p>
<p><strong>注：上面的示例会将t_student表中所有记录都删掉</strong></p>
<h4 id="7、条件语句"><a href="#7、条件语句" class="headerlink" title="7、条件语句"></a>7、条件语句</h4><p><strong>如果只想更新或者删除某些固定的记录，那就必须在DML语句后加上一些条件</strong></p>
<h6 id="条件语句的常见格式"><a href="#条件语句的常见格式" class="headerlink" title="条件语句的常见格式"></a>条件语句的常见格式</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">where 字段 = 某个值 ;   <span class="comment">// 不能用两个 =</span></div><div class="line">where 字段 is 某个值 ;   <span class="comment">// is 相当于 = </span></div><div class="line">where 字段 != 某个值 ; </div><div class="line">where 字段 is not 某个值 ;   <span class="comment">// is not 相当于 != </span></div><div class="line">where 字段 &gt; 某个值 ; </div><div class="line">where 字段<span class="number">1</span> = 某个值 and 字段<span class="number">2</span> &gt; 某个值 ;  <span class="comment">// and相当于C语言中的 &amp;&amp;</span></div><div class="line">where 字段<span class="number">1</span> = 某个值 or 字段<span class="number">2</span> = 某个值 ;  <span class="comment">//  or 相当于C语言中的 ||</span></div></pre></td></tr></table></figure>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">将t_student表中年龄大于<span class="number">10</span> 并且 姓名不等于jack的记录，年龄都改为 <span class="number">5</span></div><div class="line">update t_student set age = <span class="number">5</span> where age &gt; <span class="number">10</span> and name != ‘jack’ ;</div><div class="line"></div><div class="line">删除t_student表中年龄小于等于<span class="number">10</span> 或者 年龄大于<span class="number">30</span>的记录</div><div class="line">delete from t_student where age &lt;= <span class="number">10</span> or age &gt; <span class="number">30</span> ;</div><div class="line"></div><div class="line">猜猜下面语句的作用</div><div class="line">update t_student set score = age where name = ‘jack’ ;</div><div class="line">将t_student表中名字等于jack的记录，score字段的值 都改为 age字段的值</div></pre></td></tr></table></figure>
<h4 id="8、查询"><a href="#8、查询" class="headerlink" title="8、查询"></a>8、查询</h4><h6 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a>格式</h6><ul>
<li>select 字段1, 字段2, … from 表名 ;</li>
<li>select * from 表名;   //  查询所有的字段</li>
</ul>
<h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><ul>
<li>select name, age from t_student ;</li>
<li>select * from t_student ;</li>
<li>select * from t_student where age &gt; 10 ;  //  条件查询</li>
</ul>
<h4 id="9、起别名"><a href="#9、起别名" class="headerlink" title="9、起别名"></a>9、起别名</h4><h6 id="格式-字段和表都可以起别名"><a href="#格式-字段和表都可以起别名" class="headerlink" title="格式(字段和表都可以起别名)"></a>格式(字段和表都可以起别名)</h6><ul>
<li>select 字段1 别名 , 字段2 别名 , … from 表名 别名 ; </li>
<li>select 字段1 别名, 字段2 as 别名, … from 表名 as 别名 ;</li>
<li>select 别名.字段1, 别名.字段2, … from 表名 别名 ;</li>
</ul>
<h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><ul>
<li>select name myname, age myage from t_student ;</li>
<li>给name起个叫做myname的别名，给age起个叫做myage的别名</li>
<li>select s.name, s.age from t_student s ;</li>
<li>给t_student表起个别名叫做s，利用s来引用表中的字段</li>
</ul>
<h4 id="10、计算记录的数量"><a href="#10、计算记录的数量" class="headerlink" title="10、计算记录的数量"></a>10、计算记录的数量</h4><h6 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a>格式</h6><ul>
<li>select count (字段) from 表名 ;</li>
<li>select count ( * ) from 表名 ;<h6 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h6></li>
<li>select count (age) from t_student ;</li>
<li>select count ( * ) from t_student where score &gt;= 60;</li>
</ul>
<h4 id="11、排序"><a href="#11、排序" class="headerlink" title="11、排序"></a>11、排序</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">查询出来的结果可以用order by进行排序</div><div class="line">select * from t_student order by 字段 ;</div><div class="line">select * from t_student order by age ;</div><div class="line"></div><div class="line">默认是按照升序排序（由小到大），也可以变为降序（由大到小）</div><div class="line">select * from t_student order by age desc ;  <span class="comment">//降序</span></div><div class="line">select * from t_student order by age asc ;   <span class="comment">// 升序（默认）</span></div><div class="line"></div><div class="line">也可以用多个字段进行排序</div><div class="line">select * from t_student order by age asc, height desc ;</div><div class="line">先按照年龄排序（升序），年龄相等就按照身高排序（降序）</div></pre></td></tr></table></figure>
<h4 id="12、limit"><a href="#12、limit" class="headerlink" title="12、limit"></a>12、limit</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">使用limit可以精确地控制查询结果的数量，比如每次只查询<span class="number">10</span>条数据</div><div class="line">格式：</div><div class="line">select * from 表名 limit 数值<span class="number">1</span>, 数值<span class="number">2</span> ;</div><div class="line">示例：</div><div class="line">select * from t_student limit <span class="number">4</span>, <span class="number">8</span> ;</div><div class="line">可以理解为：跳过最前面<span class="number">4</span>条语句，然后取<span class="number">8</span>条记录</div><div class="line"></div><div class="line">limit常用来做分页查询，比如每页固定显示<span class="number">5</span>条数据，那么应该这样取数据</div><div class="line">第<span class="number">1</span>页：limit <span class="number">0</span>, <span class="number">5</span></div><div class="line">第<span class="number">2</span>页：limit <span class="number">5</span>, <span class="number">5</span></div><div class="line">第<span class="number">3</span>页：limit <span class="number">10</span>, <span class="number">5</span></div><div class="line">…</div><div class="line">第n页：limit <span class="number">5</span>*(n<span class="number">-1</span>), <span class="number">5</span></div><div class="line"></div><div class="line">猜猜下面语句的作用</div><div class="line">select * from t_student limit <span class="number">7</span> ;</div><div class="line">相当于select * from t_student limit <span class="number">0</span>, <span class="number">7</span> ;</div><div class="line">表示取最前面的<span class="number">7</span>条记录</div></pre></td></tr></table></figure>
<h4 id="13、简单约束"><a href="#13、简单约束" class="headerlink" title="13、简单约束"></a>13、简单约束</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">建表时可以给特定的字段设置一些约束条件，常见的约束有</div><div class="line">not null ：规定字段的值不能为null</div><div class="line">unique ：规定字段的值必须唯一</div><div class="line"><span class="keyword">default</span> ：指定字段的默认值</div><div class="line">（建议：尽量给字段设定严格的约束，以保证数据的规范性）</div><div class="line"></div><div class="line">示例</div><div class="line">create table t_student (<span class="keyword">id</span> integer, name text not null unique, age integer not null <span class="keyword">default</span> <span class="number">1</span>) ;</div><div class="line">name字段不能为null，并且唯一</div><div class="line">age字段不能为null，并且默认为<span class="number">1</span></div></pre></td></tr></table></figure>
<h4 id="14、主键约束"><a href="#14、主键约束" class="headerlink" title="14、主键约束"></a>14、主键约束</h4><p>如果t_student表中就name和age两个字段，而且有些记录的name和age字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据</p>
<h6 id="主键的设计原则"><a href="#主键的设计原则" class="headerlink" title="主键的设计原则"></a>主键的设计原则</h6><ul>
<li>主键应当是对用户没有意义的</li>
<li>永远也不要更新主键</li>
<li>主键不应包含动态变化的数据</li>
<li>主键应当由计算机自动生成</li>
</ul>
<h6 id="主键的声明"><a href="#主键的声明" class="headerlink" title="主键的声明"></a>主键的声明</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">在创表的时候用primary key声明一个主键</div><div class="line">create table t_student (<span class="keyword">id</span> integer primary key, name text, age integer) ;</div><div class="line">integer类型的<span class="keyword">id</span>作为t_student表的主键</div><div class="line"></div><div class="line">主键字段</div><div class="line">只要声明为primary key，就说明是一个主键字段</div><div class="line">主键字段默认就包含了not null 和 unique 两个约束</div><div class="line"></div><div class="line">如果想要让主键自动增长（必须是integer类型），应该增加autoincrement</div><div class="line">create table t_student (<span class="keyword">id</span> integer primary key autoincrement, name text, age integer) ;</div></pre></td></tr></table></figure>
<h4 id="15、外键约束"><a href="#15、外键约束" class="headerlink" title="15、外键约束"></a>15、外键约束</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">利用外键约束可以用来建立表与表之间的联系</div><div class="line">外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段</div><div class="line"></div><div class="line">新建一个外键</div><div class="line">create table t_student (<span class="keyword">id</span> integer primary key autoincrement, name text, age integer, class_id integer, constraint fk_t_student_class_id_t_class_id foreign key (class_id) references t_class (<span class="keyword">id</span>)) ; </div><div class="line">t_student表中有一个叫做fk_t_student_class_id_t_class_id的外键</div><div class="line">这个外键的作用是用t_student表中的class_id字段引用t_class表的<span class="keyword">id</span>字段</div></pre></td></tr></table></figure>
<h4 id="16、表连接查询"><a href="#16、表连接查询" class="headerlink" title="16、表连接查询"></a>16、表连接查询</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">什么是表连接查询</div><div class="line">需要联合多张表才能查到想要的数据</div><div class="line"></div><div class="line">表连接的类型</div><div class="line">内连接：inner join 或者 join  （显示的是左右表都有完整字段值的记录）</div><div class="line">左外连接：left outer join （保证左表数据的完整性）</div><div class="line"></div><div class="line">示例</div><div class="line">查询<span class="number">0316</span>iOS班的所有学生</div><div class="line">select s.name,s.age from t_student s, t_class c where s.class_id = c.id and c.name = ‘<span class="number">0316</span>iOS’;</div></pre></td></tr></table></figure>
<h2 id="三、SQLite编码"><a href="#三、SQLite编码" class="headerlink" title="三、SQLite编码"></a>三、SQLite编码</h2><h4 id="1、创建、打开、关闭数据库"><a href="#1、创建、打开、关闭数据库" class="headerlink" title="1、创建、打开、关闭数据库"></a>1、创建、打开、关闭数据库</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">创建或打开数据库</div><div class="line"><span class="comment">// path是数据库文件的存放路径</span></div><div class="line">sqlite3 *db = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">int</span> result = sqlite3_open([path UTF8String], &amp;db); </div><div class="line"></div><div class="line">代码解析：</div><div class="line">sqlite3_open()将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果result等于常量SQLITE_OK，则表示成功打开数据库</div><div class="line">sqlite3 *db：一个打开的数据库实例</div><div class="line">数据库文件的路径必须以C字符串(而非<span class="built_in">NSString</span>)传入</div><div class="line"></div><div class="line">关闭数据库：sqlite3_close(db);</div></pre></td></tr></table></figure>
<h4 id="2、执行不返回数据的SQL语句"><a href="#2、执行不返回数据的SQL语句" class="headerlink" title="2、执行不返回数据的SQL语句"></a>2、执行不返回数据的SQL语句</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">执行创表语句</div><div class="line"><span class="keyword">char</span> *errorMsg = <span class="literal">NULL</span>;  <span class="comment">// 用来存储错误信息</span></div><div class="line"><span class="keyword">char</span> *sql = <span class="string">"create table if not exists t_person(id integer primary key autoincrement, name text, age integer);"</span>;</div><div class="line"><span class="keyword">int</span> result = sqlite3_exec(db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errorMsg);</div><div class="line"></div><div class="line">代码解析：</div><div class="line">sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据</div><div class="line">sqlite3_exec()还可以执行的语句：</div><div class="line">开启事务：begin transaction;</div><div class="line">回滚事务：rollback;</div><div class="line">提交事务：commit;</div></pre></td></tr></table></figure>
<h4 id="3、带占位符插入数据"><a href="#3、带占位符插入数据" class="headerlink" title="3、带占位符插入数据"></a>3、带占位符插入数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *sql = <span class="string">"insert into t_person(name, age) values(?, ?);"</span>;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, <span class="string">"母鸡"</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    sqlite3_bind_int(stmt, <span class="number">2</span>, <span class="number">27</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (sqlite3_step(stmt) != SQLITE_DONE) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"插入数据错误"</span>);</div><div class="line">&#125;</div><div class="line">sqlite3_finalize(stmt);</div><div class="line"></div><div class="line">代码解析：</div><div class="line">sqlite3_prepare_v2()返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题</div><div class="line"></div><div class="line">sqlite3_bind_text()：大部分绑定函数都只有<span class="number">3</span>个参数</div><div class="line">第<span class="number">1</span>个参数是sqlite3_stmt *类型</div><div class="line">第<span class="number">2</span>个参数指占位符的位置，第一个占位符的位置是<span class="number">1</span>，不是<span class="number">0</span></div><div class="line">第<span class="number">3</span>个参数指占位符要绑定的值</div><div class="line">第<span class="number">4</span>个参数指在第<span class="number">3</span>个参数中所传递数据的长度，对于C字符串，可以传递<span class="number">-1</span>代替字符串的长度</div><div class="line">第<span class="number">5</span>个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作</div><div class="line">sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕</div><div class="line">sqlite_finalize()：销毁sqlite3_stmt *对象</div></pre></td></tr></table></figure>
<h4 id="4、查询数据"><a href="#4、查询数据" class="headerlink" title="4、查询数据"></a>4、查询数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *sql = <span class="string">"select id,name,age from t_person;"</span>;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</div><div class="line">    <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line">        <span class="keyword">int</span> _<span class="keyword">id</span> = sqlite3_column_int(stmt, <span class="number">0</span>);</div><div class="line">        <span class="keyword">char</span> *_name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</div><div class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:_name];</div><div class="line">        <span class="keyword">int</span> _age = sqlite3_column_int(stmt, <span class="number">2</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"id=%i, name=%@, age=%i"</span>, _<span class="keyword">id</span>, name, _age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">sqlite3_finalize(stmt);</div><div class="line">代码解析</div><div class="line">sqlite3_step()返回SQLITE_ROW代表遍历到一条新记录</div><div class="line">sqlite3_column_*()用于获取每个字段对应的值，第<span class="number">2</span>个参数是字段的索引，从<span class="number">0</span>开始</div></pre></td></tr></table></figure>
<h2 id="四、附件"><a href="#四、附件" class="headerlink" title="四、附件"></a>四、附件</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">/*简单约束*/</div><div class="line">CREATE TABLE IF NOT EXISTS t_student(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, age INTEGER);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER DEFAULT 1);</div><div class="line"></div><div class="line">/*分页*/</div><div class="line">SELECT * FROM t_student ORDER BY id ASC LIMIT 30, 10;</div><div class="line"></div><div class="line">/*排序*/</div><div class="line">SELECT * FROM t_student WHERE score &gt; 50 ORDER BY age DESC;</div><div class="line">SELECT * FROM t_student WHERE score &lt; 50 ORDER BY age ASC , score DESC;</div><div class="line"></div><div class="line">/*计量*/</div><div class="line">SELECT COUNT(*) FROM t_student WHERE age &gt; 50;</div><div class="line"></div><div class="line">/*别名*/</div><div class="line">SELECT name as myName, age as myAge, score as myScore FROM t_student;</div><div class="line">SELECT name myName, age myAge, score myScore FROM t_student;</div><div class="line">SELECT s.name myName, s.age myAge, s.score myScore FROM t_student s WHERE s.age &gt; 50;</div><div class="line"></div><div class="line">/*查询*/</div><div class="line">SELECT name, age, score FROM t_student;</div><div class="line">SELECT * FROM t_student;</div><div class="line"></div><div class="line">/*修改指定数据*/</div><div class="line">UPDATE t_student SET name = 'MM' WHERE age = 10;</div><div class="line">UPDATE t_student SET name = 'WW' WHERE age is 7;</div><div class="line">UPDATE t_student SET name = 'XXOO' WHERE age &lt; 20;</div><div class="line">UPDATE t_student SET name = 'NNMM' WHERE age &lt; 50 and score &gt; 10;</div><div class="line"></div><div class="line">/*删除数据*/</div><div class="line">DELETE FROM t_student;</div><div class="line"></div><div class="line">/*更新数据*/</div><div class="line">UPDATE t_student SET name = 'LNJ';</div><div class="line"></div><div class="line">/*插入数据*/</div><div class="line"> INSERT INTO t_student(age, score, name) VALUES ('28', 100, 'jonathan');</div><div class="line"> INSERT INTO t_student(name, age) VALUES ('lee', '28');</div><div class="line"> INSERT INTO t_student(score) VALUES (100);</div><div class="line"></div><div class="line">/*插入数据*/</div><div class="line">INSERT INTO t_student(name, age, score) VALUES ('lee', '28', 100);</div><div class="line"></div><div class="line">/*添加主键*/</div><div class="line">CREATE TABLE IF NOT EXISTS t_student (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER, score REAL);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student (id INTEGER PRIMARY KEY, name TEXT, age INTEGER, score REAL);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student (id INTEGER, name TEXT, age INTEGER, score REAL, PRIMARY KEY(id));</div><div class="line"></div><div class="line">/*删除表*/</div><div class="line">DROP TABLE t_student;</div><div class="line">DROP TABLE IF EXISTS t_student;</div><div class="line"></div><div class="line">/*创建表*/</div><div class="line">CREATE TABLE t_student(id INTEGER , name TEXT, age , score REAL);</div><div class="line">CREATE TABLE IF NOT EXISTS t_student(id INTEGER , name TEXT, age , score REAL);</div></pre></td></tr></table></figure>
<h4 id="1-打开数据库"><a href="#1-打开数据库" class="headerlink" title="1.打开数据库"></a>1.打开数据库</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_open(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filename,   <span class="comment">// 数据库的文件路径</span></div><div class="line">    sqlite3 **ppDb          <span class="comment">// 数据库实例</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="2、执行任何SQL语句"><a href="#2、执行任何SQL语句" class="headerlink" title="2、执行任何SQL语句"></a>2、执行任何SQL语句</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_exec(</div><div class="line">    sqlite3*,                                  <span class="comment">// 一个打开的数据库实例</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql,                           <span class="comment">// 需要执行的SQL语句</span></div><div class="line">    <span class="keyword">int</span> (*callback)(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">char</span>**,<span class="keyword">char</span>**),  <span class="comment">// SQL语句执行完毕后的回调</span></div><div class="line">    <span class="keyword">void</span> *,                                    <span class="comment">// 回调函数的第1个参数</span></div><div class="line">    <span class="keyword">char</span> **errmsg                              <span class="comment">// 错误信息</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="3、检查SQL语句的合法性"><a href="#3、检查SQL语句的合法性" class="headerlink" title="3、检查SQL语句的合法性"></a>3、检查SQL语句的合法性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_prepare_v2(</div><div class="line">    sqlite3 *db,            <span class="comment">// 数据库实例</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *zSql,       <span class="comment">// 需要检查的SQL语句</span></div><div class="line">    <span class="keyword">int</span> nByte,              <span class="comment">// SQL语句的最大字节长度</span></div><div class="line">    sqlite3_stmt **ppStmt,  <span class="comment">// sqlite3_stmt实例，用来获得数据库数据</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **pzTail</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="4、查询一行数据"><a href="#4、查询一行数据" class="headerlink" title="4、查询一行数据"></a>4、查询一行数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_step(sqlite3_stmt*); <span class="comment">// 如果查询到一行数据，就会返回</span></div></pre></td></tr></table></figure>
<h4 id="5、利用stmt获得某一字段的值"><a href="#5、利用stmt获得某一字段的值" class="headerlink" title="5、利用stmt获得某一字段的值"></a>5、利用stmt获得某一字段的值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> sqlite3_column_double(sqlite3_stmt*, <span class="keyword">int</span> iCol);  <span class="comment">// 浮点数据</span></div><div class="line"><span class="keyword">int</span> sqlite3_column_int(sqlite3_stmt*, <span class="keyword">int</span> iCol); <span class="comment">// 整型数据</span></div><div class="line">sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, <span class="keyword">int</span> iCol); <span class="comment">// 长整型数据</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Lonely920" />
          <p class="site-author-name" itemprop="name">Lonely920</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lonely920</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
