<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Lonely920" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Lonely920">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Lonely920">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lonely920">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> Lonely920 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lonely920</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Sun</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/CALayer/" itemprop="url">
                  CALayer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T10:31:23+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/提高篇/" itemprop="url" rel="index">
                    <span itemprop="name">提高篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul>
<li><p>在iOS中，你能看得见摸得着的东西基本上都是UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是UIView，<strong>其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层</strong></p>
</li>
<li><p>在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">CALayer</span> *layer;</div></pre></td></tr></table></figure>
</li>
<li><p>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上(layer)，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示</p>
</li>
</ul>
<p>*换句话说，UIView本身不具备显示的功能，是它内部的层才有显示功能</p>
<h2 id="二、CALayer应用"><a href="#二、CALayer应用" class="headerlink" title="二、CALayer应用"></a>二、CALayer应用</h2><h4 id="1、CALayer的属性"><a href="#1、CALayer的属性" class="headerlink" title="1、CALayer的属性"></a>1、CALayer的属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="built_in">CGFloat</span> borderWidth;				<span class="comment">//边框宽度</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> borderColor;			<span class="comment">//边框颜色(CGColorRef类型)</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> backgroundColor; 		<span class="comment">//背景颜色</span></div><div class="line"><span class="keyword">@property</span> <span class="keyword">float</span> opacity;					<span class="comment">//透明度</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> shadowColor; 			<span class="comment">//阴影颜色</span></div><div class="line"><span class="keyword">@property</span> <span class="keyword">float</span> shadowOpacity;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGSize</span> shadowOffset;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGFloat</span> shadowRadius;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>) <span class="keyword">id</span> contents;				内容(比如设置为图片<span class="built_in">CGImageRef</span>)</div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGFloat</span> cornerRadius;				<span class="comment">//圆角半径</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGRect</span> bounds;					<span class="comment">//宽度和高度</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> position;					<span class="comment">//位置(默认指中点，具体由anchorPoint决定)</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> anchorPoint;				<span class="comment">//锚点(x,y的范围都是0-1)，决定了position的含义</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">CATransform3D</span> transform;			<span class="comment">//形变属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">getter</span>=isHidden) <span class="built_in">BOOL</span> hidden;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">CALayer</span> *superlayer;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSArray</span> *sublayers;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> masksToBounds;</div></pre></td></tr></table></figure>
<h4 id="2、UIView和CALayer的选择"><a href="#2、UIView和CALayer的选择" class="headerlink" title="2、UIView和CALayer的选择"></a>2、UIView和CALayer的选择</h4><ul>
<li><p>通过CALayer，就能做出跟UIImageView一样的界面效果</p>
</li>
<li><p>既然CALayer和UIView都能实现相同的显示效果，那究竟该选择谁好呢？</p>
<ul>
<li>其实，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以</li>
<li><p>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级</p>
<p><strong>UIView ： 接受和处理系统事件、触摸事件。</strong></p>
<p><strong>CALayer ： 显示内容</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="3、position和anchorPoint"><a href="#3、position和anchorPoint" class="headerlink" title="3、position和anchorPoint"></a>3、position和anchorPoint</h4><h6 id="1、-property-CGPoint-position"><a href="#1、-property-CGPoint-position" class="headerlink" title="1、@property CGPoint position;"></a>1、@property CGPoint position;</h6><ul>
<li>用来设置CALayer在父层中的位置</li>
<li>以父层的左上角为原点(0, 0)</li>
</ul>
<h6 id="2、-property-CGPoint-anchorPoint"><a href="#2、-property-CGPoint-anchorPoint" class="headerlink" title="2、@property CGPoint anchorPoint;"></a>2、@property CGPoint anchorPoint;</h6><ul>
<li>称为“定位点”、“锚点”</li>
<li>决定着CALayer的position属性所指的是哪个点</li>
<li>以自己的左上角为原点(0, 0)</li>
<li>它的x、y取值范围都是0~1，默认值为（0.5, 0.5）</li>
</ul>
<h4 id="4、隐式动画"><a href="#4、隐式动画" class="headerlink" title="4、隐式动画"></a>4、隐式动画</h4><ul>
<li>每一个UIView内部都默认关联着一个CALayer, 我们可称这个Layer为Root Layer（根层）</li>
<li>所有的非Root Layer, 也就是手动创建的CALayer对象, 都存在着隐式动画。 root layer 是没有隐式动画的</li>
<li><strong>可以通过动画事务(CATransaction)关闭默认的隐式动画效果</strong><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">CATransaction</span> begin];</div><div class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</div><div class="line"><span class="keyword">self</span>.myview.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line">[<span class="built_in">CATransaction</span> commit];</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/NSOperation/" itemprop="url">
                  NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T10:31:23+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络与多线程/" itemprop="url" rel="index">
                    <span itemprop="name">网络与多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、NSOperation简介"><a href="#一、NSOperation简介" class="headerlink" title="一、NSOperation简介"></a>一、NSOperation简介</h2><h4 id="1、NSOperation的作用"><a href="#1、NSOperation的作用" class="headerlink" title="1、NSOperation的作用"></a>1、NSOperation的作用</h4><ul>
<li>是OC语言中基于GCD的面向对象的封装</li>
<li>使用起来比GCD更加简单（面向对象）</li>
<li>提供了一些用GCD不好实现的功能</li>
<li>苹果推荐使用，使用NSOperation不用关心线程以及线程的生命周期</li>
</ul>
<h4 id="2、查看NSOperation的头文件"><a href="#2、查看NSOperation的头文件" class="headerlink" title="2、查看NSOperation的头文件"></a>2、查看NSOperation的头文件</h4><ul>
<li>NSOperation是一个抽象类<ol>
<li>不能直接使用（方法没有实现）</li>
<li>约束子类都具有共同的属性和方法</li>
</ol>
</li>
<li>NSOperation的子类<ol>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义operation</li>
</ol>
</li>
</ul>
<h4 id="3、使用步骤"><a href="#3、使用步骤" class="headerlink" title="3、使用步骤"></a>3、使用步骤</h4><h6 id="NSOperation和NSOperationQueue实现多线程的具体步骤"><a href="#NSOperation和NSOperationQueue实现多线程的具体步骤" class="headerlink" title="NSOperation和NSOperationQueue实现多线程的具体步骤"></a>NSOperation和NSOperationQueue实现多线程的具体步骤</h6><ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h2 id="二、NSOperation"><a href="#二、NSOperation" class="headerlink" title="二、NSOperation"></a>二、NSOperation</h2><h4 id="1、NSInvocationOperation"><a href="#1、NSInvocationOperation" class="headerlink" title="1、NSInvocationOperation"></a>1、NSInvocationOperation</h4><h6 id="建NSInvocationOperation对象"><a href="#建NSInvocationOperation对象" class="headerlink" title="建NSInvocationOperation对象"></a>建NSInvocationOperation对象</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel object:(<span class="keyword">id</span>)arg;</div></pre></td></tr></table></figure>
<h6 id="调用start方法开始执行操作"><a href="#调用start方法开始执行操作" class="headerlink" title="调用start方法开始执行操作"></a>调用start方法开始执行操作</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start;</div></pre></td></tr></table></figure>
<p><strong>一旦执行操作，就会调用target的sel方法</strong></p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul>
<li>默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作</li>
<li>只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作,年代久远，不常用。</li>
</ul>
<h4 id="2、NSBlockOperation"><a href="#2、NSBlockOperation" class="headerlink" title="2、NSBlockOperation"></a>2、NSBlockOperation</h4><h6 id="创建NSBlockOperation对象"><a href="#创建NSBlockOperation对象" class="headerlink" title="创建NSBlockOperation对象"></a>创建NSBlockOperation对象</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)blockOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<h6 id="通过addExecutionBlock-方法添加更多的操作"><a href="#通过addExecutionBlock-方法添加更多的操作" class="headerlink" title="通过addExecutionBlock:方法添加更多的操作"></a>通过addExecutionBlock:方法添加更多的操作</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addExecutionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<p><strong>注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作</strong></p>
<h4 id="3、NSOperationQueue"><a href="#3、NSOperationQueue" class="headerlink" title="3、NSOperationQueue"></a>3、NSOperationQueue</h4><h6 id="NSOperationQueue的作用"><a href="#NSOperationQueue的作用" class="headerlink" title="NSOperationQueue的作用"></a>NSOperationQueue的作用</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperation</span>可以调用start方法来执行任务，但默认是同步执行的</div><div class="line">如果将<span class="built_in">NSOperation</span>添加到<span class="built_in">NSOperationQueue</span>（操作队列）中，系统会自动异步执行<span class="built_in">NSOperation</span>中的操作</div></pre></td></tr></table></figure>
<h6 id="添加操作到NSOperationQueue中"><a href="#添加操作到NSOperationQueue中" class="headerlink" title="添加操作到NSOperationQueue中"></a>添加操作到NSOperationQueue中</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</div><div class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<h6 id="监听操作完成"><a href="#监听操作完成" class="headerlink" title="监听操作完成"></a>监听操作完成</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以监听一个操作的执行完毕</div><div class="line">- (<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionBlock;</div><div class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<h4 id="4、最大并发数"><a href="#4、最大并发数" class="headerlink" title="4、最大并发数"></a>4、最大并发数</h4><h6 id="什么是并发数"><a href="#什么是并发数" class="headerlink" title="什么是并发数"></a>什么是并发数</h6><ul>
<li>同时执行的任务数</li>
<li>比如，同时开3个线程执行3个任务，并发数就是3</li>
</ul>
<h6 id="最大并发数的相关方法"><a href="#最大并发数的相关方法" class="headerlink" title="最大并发数的相关方法"></a>最大并发数的相关方法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)maxConcurrentOperationCount;</div><div class="line">- (<span class="keyword">void</span>)setMaxConcurrentOperationCount:(<span class="built_in">NSInteger</span>)cnt;</div></pre></td></tr></table></figure>
<h4 id="5、队列的暂停、取消、恢复"><a href="#5、队列的暂停、取消、恢复" class="headerlink" title="5、队列的暂停、取消、恢复"></a>5、队列的暂停、取消、恢复</h4><h6 id="取消队列的所有操作"><a href="#取消队列的所有操作" class="headerlink" title="取消队列的所有操作"></a>取消队列的所有操作</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cancelAllOperations;</div><div class="line">提示：也可以调用<span class="built_in">NSOperation</span>的- (<span class="keyword">void</span>)cancel方法取消单个操作</div></pre></td></tr></table></figure>
<h6 id="暂停和恢复队列"><a href="#暂停和恢复队列" class="headerlink" title="暂停和恢复队列"></a>暂停和恢复队列</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)b; <span class="comment">// YES代表暂停队列，NO代表恢复队列</span></div><div class="line">- (<span class="built_in">BOOL</span>)isSuspended;</div></pre></td></tr></table></figure>
<h4 id="6、操作的优先级"><a href="#6、操作的优先级" class="headerlink" title="6、操作的优先级"></a>6、操作的优先级</h4><h6 id="设置NSOperation在queue中的优先级，可以改变操作的执行优先级"><a href="#设置NSOperation在queue中的优先级，可以改变操作的执行优先级" class="headerlink" title="设置NSOperation在queue中的优先级，可以改变操作的执行优先级"></a>设置NSOperation在queue中的优先级，可以改变操作的执行优先级</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperationQueuePriority</span>)queuePriority;</div><div class="line">- (<span class="keyword">void</span>)setQueuePriority:(<span class="built_in">NSOperationQueuePriority</span>)p;</div></pre></td></tr></table></figure>
<h6 id="优先级的取值"><a href="#优先级的取值" class="headerlink" title="优先级的取值"></a>优先级的取值</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperationQueuePriorityVeryLow</span> = <span class="number">-8</span>L,</div><div class="line"><span class="built_in">NSOperationQueuePriorityLow</span> = <span class="number">-4</span>L,</div><div class="line"><span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</div><div class="line"><span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</div><div class="line"><span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></div><div class="line"></div><div class="line">iOS8 <span class="keyword">@property</span> <span class="built_in">NSQualityOfService</span> qualityOfService</div><div class="line"></div><div class="line"><span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>,</div><div class="line"><span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,</div><div class="line"><span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,</div><div class="line"><span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,</div><div class="line"><span class="built_in">NSQualityOfServiceDefault</span> = <span class="number">-1</span></div></pre></td></tr></table></figure>
<h4 id="7、操作依赖"><a href="#7、操作依赖" class="headerlink" title="7、操作依赖"></a>7、操作依赖</h4><h6 id="NSOperation之间可以设置依赖来保证执行顺序"><a href="#NSOperation之间可以设置依赖来保证执行顺序" class="headerlink" title="NSOperation之间可以设置依赖来保证执行顺序"></a>NSOperation之间可以设置依赖来保证执行顺序</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">比如一定要让操作A执行完后，才能执行操作B，可以这么写</div><div class="line">[operationB addDependency:operationA]; <span class="comment">// 操作B依赖于操作A</span></div><div class="line">可以在不同queue的<span class="built_in">NSOperation</span>之间创建依赖关系</div></pre></td></tr></table></figure>
<p><strong>注意不能相符依赖</strong></p>
<h4 id="8、线程间通信"><a href="#8、线程间通信" class="headerlink" title="8、线程间通信"></a>8、线程间通信</h4><h6 id="子线程-gt-主线程"><a href="#子线程-gt-主线程" class="headerlink" title="子线程-&gt;主线程"></a>子线程-&gt;主线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.queue addOperationWithBlock:^&#123;</div><div class="line">        <span class="comment">//子线程</span></div><div class="line">        <span class="comment">//do something</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            <span class="comment">//主线程的任务,操作UI等</span></div><div class="line">        &#125;];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h4 id="9、自定义NSOperation"><a href="#9、自定义NSOperation" class="headerlink" title="9、自定义NSOperation"></a>9、自定义NSOperation</h4><h6 id="重写main方法，把我们想要执行的代码放到该方法中去运行。"><a href="#重写main方法，把我们想要执行的代码放到该方法中去运行。" class="headerlink" title="重写main方法，把我们想要执行的代码放到该方法中去运行。"></a>重写main方法，把我们想要执行的代码放到该方法中去运行。</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)main;</div></pre></td></tr></table></figure>
<h2 id="3、NSOperation-VS-GCD"><a href="#3、NSOperation-VS-GCD" class="headerlink" title="3、NSOperation VS GCD"></a>3、NSOperation VS GCD</h2><h4 id="1、GCD"><a href="#1、GCD" class="headerlink" title="1、GCD"></a>1、GCD</h4><pre><code>i.  GCD是iOS4.0 推出的，主要针对多核cpu做了优化，是C语言的技术
ii. GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数
iii.GCD提供了一些NSOperation不具备的功能
1.    一次性执行
2.    延迟执行
3.    调度组
</code></pre><h4 id="2、NSOperation"><a href="#2、NSOperation" class="headerlink" title="2、NSOperation"></a>2、NSOperation</h4><pre><code>i.  NSOperation是iOS2.0推出的，iOS4之后重写了NSOperation
ii.    NSOperation将操作(异步的任务)添加到队列(并发队列)，就会执行指定操作的函数
iii.NSOperation里提供的方便的操作
1.    最大并发数
2.    队列的暂定/继续
3.    取消所有的操作
4.    指定操作之间的依赖关系(GCD可以用同步实现)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/NSNumber:NSValue的介绍/" itemprop="url">
                  NSNumber/NSValue的介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T10:30:28+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、NSNumber的介绍"><a href="#一、NSNumber的介绍" class="headerlink" title="一、NSNumber的介绍"></a>一、NSNumber的介绍</h2><h4 id="1、NSNumber的介绍和使用"><a href="#1、NSNumber的介绍和使用" class="headerlink" title="1、NSNumber的介绍和使用"></a>1、NSNumber的介绍和使用</h4><ul>
<li><p>NSArray\NSDictionary中只能存放OC对象,不能存放int\float\double等基本数据类型。</p>
</li>
<li><p>如果真想把基本数据(比如int)放进数组或字典中,需要先将基本数据类型包装成OC对象。</p>
</li>
<li><p>基本数据类型（如int）–<code>包装</code>–&gt;OC对象–<code>放进</code>–&gt;数组/字典</p>
</li>
<li><p>NSNumber可以将基本数据类型包装成对象,这样就可以间接将基本数据类型存进NSArray\NSDictionary中</p>
</li>
<li>基本数据类型（如int）–<code>包装</code>–&gt;NSNumber对象–<code>放进</code>–&gt;数组/字典</li>
</ul>
<h4 id="2、NSNumber的创建"><a href="#2、NSNumber的创建" class="headerlink" title="2、NSNumber的创建"></a>2、NSNumber的创建</h4><ul>
<li><p>以前</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithInt:(<span class="keyword">int</span>)value;</div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithDouble:(<span class="keyword">double</span>)value;</div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithBool:(<span class="built_in">BOOL</span>)value;</div></pre></td></tr></table></figure>
</li>
<li><p>现在</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="number">10</span>; 	@<span class="number">10.5</span>; 	 @YES; 	 @(num);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3、从NSNumber对象中得到基本类型数据"><a href="#3、从NSNumber对象中得到基本类型数据" class="headerlink" title="3、从NSNumber对象中得到基本类型数据"></a>3、从NSNumber对象中得到基本类型数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">char</span>)charValue;</div><div class="line">- (<span class="keyword">int</span>)intValue;</div><div class="line">- (<span class="keyword">long</span>)longValue;</div><div class="line">- (<span class="keyword">double</span>)doubleValue;</div><div class="line">- (<span class="built_in">BOOL</span>)boolValue;</div><div class="line">- (<span class="built_in">NSString</span> *)stringValue;</div><div class="line"></div><div class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSNumber</span> *)otherNumber;</div><div class="line">- (<span class="built_in">BOOL</span>)isEqualToNumber:(<span class="built_in">NSNumber</span> *)number;</div></pre></td></tr></table></figure>
<h2 id="二、NSValue的介绍和使用"><a href="#二、NSValue的介绍和使用" class="headerlink" title="二、NSValue的介绍和使用"></a>二、NSValue的介绍和使用</h2><ul>
<li><strong>NSNumber是NSValue的子类, 但NSNumber只能包装数字类型</strong></li>
<li><strong>NSValue可以包装任意值，因此,可以用NSValue将结构体包装后, 加入NSArray\NSDictionary中。</strong></li>
</ul>
<h4 id="1、常见结构体包装"><a href="#1、常见结构体包装" class="headerlink" title="1、常见结构体包装"></a>1、常见结构体包装</h4><ul>
<li>为了方便 结构体 和NSValue的转换,Foundation提供了以下方法：</li>
<li><p>将结构体包装成NSValue对象</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithPoint:(<span class="built_in">NSPoint</span>)point;</div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithSize:(<span class="built_in">NSSize</span>)size;</div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithRect:(<span class="built_in">NSRect</span>)rect;</div></pre></td></tr></table></figure>
</li>
<li><p>从NSValue对象取出之前包装的结构体</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSPoint</span>)pointValue;</div><div class="line">- (<span class="built_in">NSSize</span>)sizeValue;</div><div class="line">- (<span class="built_in">NSRect</span>)rectValue;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、任意数据的包装"><a href="#2、任意数据的包装" class="headerlink" title="2、任意数据的包装"></a>2、任意数据的包装</h4><ul>
<li><p>NSValue提供了下列方法来包装任意数据</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithBytes:(<span class="keyword">const</span> <span class="keyword">void</span> *)value objCType:(<span class="keyword">const</span> <span class="keyword">char</span> *)type;</div></pre></td></tr></table></figure>
<ul>
<li>value参数 : 所包装数据的地址</li>
<li>type 参数 : 用来描述这个数据类型的字符串,用@encode指令来生成。</li>
</ul>
</li>
<li>从NSValue中取出所包装的数据  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)getValue:(<span class="keyword">void</span> *)value;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/copy/" itemprop="url">
                  Copy
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T10:32:54+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、copy概念及入门"><a href="#一、copy概念及入门" class="headerlink" title="一、copy概念及入门"></a>一、copy概念及入门</h2><h4 id="1、【理解】copy的概念"><a href="#1、【理解】copy的概念" class="headerlink" title="1、【理解】copy的概念"></a>1、【理解】copy的概念</h4><ul>
<li>Copy的字面意思是“复制”、“拷贝”，是一个产生副本的过程。</li>
<li><strong>常见的复制有：文件复制</strong></li>
<li>作用：利用一个源文件产生一个副本文件</li>
<li>特点：<ul>
<li>修改源文件的内容，不会影响副本文件<ul>
<li>修改副本文件的内容，不会影响源文件</li>
<li><strong> OC中的copy</strong></li>
</ul>
</li>
</ul>
</li>
<li>作用：利用一个源对象产生一个副本对象</li>
<li>特点：<ul>
<li>修改源对象的属性和行为，不会影响副本对象</li>
<li>修改副本对象的属性和行为，不会影响源对象</li>
</ul>
</li>
</ul>
<h4 id="2、copy快速入门"><a href="#2、copy快速入门" class="headerlink" title="2、copy快速入门"></a>2、copy快速入门</h4><ul>
<li><p>如何使用copy功能<br>一个对象可以调用copy或mutableCopy方法来创建一个副本对象</p>
<ul>
<li>copy : 创建的是不可变副本(如NSString、NSArray、NSDictionary)</li>
<li>mutableCopy :创建的是可变副本(如NSMutableString、NSMutableArray、NSMutableDictionary)</li>
<li><p>使用copy功能的前提<br>copy : 需要遵守NSCopying协议，实现copyWithZone:方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">@protocol</span> <span class="title">NSCopying</span></span></div><div class="line"> - (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>mutableCopy :需要遵守NSMutableCopying协议，实现mutableCopyWithZone:方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSMutableCopying</span></span></div><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="二、copy与内存管理"><a href="#二、copy与内存管理" class="headerlink" title="二、copy与内存管理"></a>二、copy与内存管理</h2><h4 id="1、copy与内存管理"><a href="#1、copy与内存管理" class="headerlink" title="1、copy与内存管理"></a>1、copy与内存管理</h4><ul>
<li>copy一次，retainCount +1</li>
</ul>
<h4 id="2、深浅拷贝总结"><a href="#2、深浅拷贝总结" class="headerlink" title="2、深浅拷贝总结"></a>2、深浅拷贝总结</h4><ul>
<li><p>深复制（深拷贝，内容拷贝，deep copy）</p>
<ul>
<li>源对象和副本对象是不同的两个对象,源对象引用计数器不变, 副本对象计数器为1（因为是新产生的）</li>
<li>本质是：产生了新的对象</li>
</ul>
</li>
<li><p>浅复制（浅拷贝，指针拷贝，shallow copy）</p>
<ul>
<li>源对象和副本对象是同一个对象，源对象（副本对象）引用计数器 + 1, 相当于做一次retain操作</li>
<li>本质是：没有产生新的对象</li>
</ul>
</li>
</ul>
<p><code>只有源对象和副本对象都不可变时，才是浅复制，其它都是深复制</code></p>
<h2 id="三、-property中的copy的关键字"><a href="#三、-property中的copy的关键字" class="headerlink" title="三、@property中的copy的关键字"></a>三、@property中的copy的关键字</h2><h4 id="1、-property中的copy作用"><a href="#1、-property中的copy作用" class="headerlink" title="1、@property中的copy作用"></a>1、@property中的copy作用</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">分析代码:</div><div class="line"><span class="comment">//创建可变字符串</span></div><div class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string]; <span class="comment">//设定字符串的内容</span></div><div class="line">str.string = <span class="string">@"zhangsan"</span>;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line">Person *person = [Person new]; <span class="comment">//给person的实例变量赋值 person.name = str;</span></div><div class="line"><span class="comment">//修改字符串内容</span></div><div class="line">[str appendString:<span class="string">@"xxxx"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"name = %@"</span>,person.name); <span class="built_in">NSLog</span>(<span class="string">@"str = %@"</span>,str);</div><div class="line"><span class="comment">// 输出结果：</span></div><div class="line">name = zhangsanxxxx</div><div class="line">str = zhangsanxxxx</div><div class="line"></div><div class="line">这显然不符合我们的要求,因为str修改后,会影响person.name 的值 解决方法:</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line">set方法展开形式为:</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (_name != name)</div><div class="line">&#123;</div><div class="line">  [_name release];</div><div class="line">  [_name release];</div><div class="line">  _name = [name mutableCopy];</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<h4 id="2、-property内存管理策略选择"><a href="#2、-property内存管理策略选择" class="headerlink" title="2、@property内存管理策略选择"></a>2、@property内存管理策略选择</h4><ul>
<li>@property内存管理策略的选择<ul>
<li>1.非ARC<ul>
<li>1&gt; copy : 只用于NSString\block</li>
<li>2&gt; retain : 除NSString\block以外的OC对象</li>
<li>3&gt; assign:基本数据类型、枚举、结构体(非OC对象),当2个对象相互引用,一端用retain,一端用assign</li>
</ul>
</li>
<li>2.ARC<ul>
<li>1&gt; copy : 只用于NSString\block</li>
<li>2&gt; strong : 除NSString\block以外的OC对象</li>
<li>3&gt; weak : 当2个对象相互引用,一端用strong,一端用weak</li>
<li>4&gt; assgin : 基本数据类型、枚举、结构体(非OC对象)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、为自定义的类实现copy操作"><a href="#四、为自定义的类实现copy操作" class="headerlink" title="四、为自定义的类实现copy操作"></a>四、为自定义的类实现copy操作</h2><h4 id="1-为自定义类实现copy操作"><a href="#1-为自定义类实现copy操作" class="headerlink" title="1.为自定义类实现copy操作"></a>1.为自定义类实现copy操作</h4><h5 id="自定义对象copy步骤"><a href="#自定义对象copy步骤" class="headerlink" title="自定义对象copy步骤"></a>自定义对象copy步骤</h5><ul>
<li>新建Person类</li>
<li>为Person类实现copy操作<ul>
<li>1.让Person类遵守NSCopying协议</li>
<li>2.实现 copyWithZone:方法,在该方法中返回一个对象的副本即可。</li>
<li>3.在copyWithZone方法中,创建一个新的对象,并设置该对象的数据与现有对象一致, 并返回该对象.</li>
<li>创建Person对象, 调用copy方法, 查看地址。</li>
</ul>
</li>
<li><p>细节介绍:</p>
<ul>
<li>1、 调用copy其实就是调用copyWithZone方法,所以要实现copyWithZone方法。(查看NSObject协议中的copy方法的介绍)</li>
<li>2、 copyWithZone方法返回值类型是id类型,需要返回一个对象的副本。</li>
<li>3、 关于copyWithZone的参数zone问题:<ul>
<li>zone: 表示空间,分配对象是需要内存空间的,如果指定了zone,就可以指定新建对象对应的内存空间。但是:zone是一个非常古老的技术,为了避免在堆中出现内存碎片而使用的。在今天的开发中,zone几乎可以忽略</li>
<li>查看NSCopying协议中的allocWithZone:方法介绍(zone参数可以被忽略,是历史 原因)</li>
</ul>
</li>
<li>4、如果对象没有 可变/不可变 的版本区别,只要实现 copyWithZone 方法即可.</li>
<li><p>5、copyWithZone:方法的具体实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line">Person *p1 = [[Person alloc] init]; <span class="comment">//用当前对象值给新对象的实例变量赋值 p1.age = self.age;</span></div><div class="line"><span class="comment">//返回新对象</span></div><div class="line"><span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>为Person类实现mutableCopy操作</p>
<ul>
<li>1.遵守NSMutableCopying协议</li>
<li><p>2.实现协议对你的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line">Person *p1 = [[Person alloc] init]; <span class="comment">//用当前对象值给新对象的实例变量赋值 p1.age = self.age;</span></div><div class="line"><span class="comment">//返回新对象</span></div><div class="line"><span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/UINavigationcontroller/" itemprop="url">
                  UINavigationController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T10:31:23+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、UINavigationController的基本使用"><a href="#一、UINavigationController的基本使用" class="headerlink" title="一、UINavigationController的基本使用"></a>一、UINavigationController的基本使用</h2><ul>
<li>初始化UINavigationController</li>
<li>设置UIWindow的rootViewController为UINavigationController</li>
<li>将第一个视图控制器设置为UINavigationController的根视图控制器</li>
<li>通过push方法新建子控制器</li>
<li>通过pop方法可以返回到上一个控制器</li>
</ul>
<h4 id="1、UINavigationController子控制器"><a href="#1、UINavigationController子控制器" class="headerlink" title="1、UINavigationController子控制器"></a>1、UINavigationController子控制器</h4><ul>
<li><p>栈内所有子控制器的集合</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIViewController</span> *&gt; *viewControllers;</div></pre></td></tr></table></figure>
</li>
<li><p>栈顶控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIViewController</span> *topViewController;</div></pre></td></tr></table></figure>
</li>
<li><p>通过push方法将控制器压栈  </p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated;</div></pre></td></tr></table></figure>
</li>
<li><p>通过pop方法将栈顶控制器移出栈</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)popViewControllerAnimated:(<span class="built_in">BOOL</span>)animated</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>回到指定控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)popToViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated;</div></pre></td></tr></table></figure>
</li>
<li><p>回到根控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)popToRootViewControllerAnimated:(<span class="built_in">BOOL</span>)animated;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、修改导航栏的内容"><a href="#2、修改导航栏的内容" class="headerlink" title="2、修改导航栏的内容"></a>2、修改导航栏的内容</h4><h6 id="导航栏的内容由栈顶控制器的navigationItem属性决定"><a href="#导航栏的内容由栈顶控制器的navigationItem属性决定" class="headerlink" title="导航栏的内容由栈顶控制器的navigationItem属性决定"></a>导航栏的内容由栈顶控制器的navigationItem属性决定</h6><h6 id="UINavigationItem有以下属性影响着导航栏的内容"><a href="#UINavigationItem有以下属性影响着导航栏的内容" class="headerlink" title="UINavigationItem有以下属性影响着导航栏的内容"></a>UINavigationItem有以下属性影响着导航栏的内容</h6><ul>
<li><p>左上角的返回按钮</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIBarButtonItem</span> *backBarButtonItem;</div></pre></td></tr></table></figure>
</li>
<li><p>中间的标题视图</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span>          *titleView;</div></pre></td></tr></table></figure>
</li>
<li><p>中间的标题文字</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSString</span>        *title;</div></pre></td></tr></table></figure>
</li>
<li><p>左上角的按钮</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIBarButtonItem</span> *leftBarButtonItem;</div></pre></td></tr></table></figure>
</li>
<li><p>右上角的按钮</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="built_in">UIBarButtonItem</span> *rightBarButtonItem;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="当子控制器重新设置了返回键怎样保留手势退出功能"><a href="#当子控制器重新设置了返回键怎样保留手势退出功能" class="headerlink" title="当子控制器重新设置了返回键怎样保留手势退出功能"></a>当子控制器重新设置了返回键怎样保留手势退出功能</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保留pop手势（清空代理，让控制器重新设置这个功能滑动移除控制器）</span></div><div class="line"><span class="keyword">self</span>.interactivePopGestureRecognizer.delegate = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<h4 id="3、UINavigationBar属性"><a href="#3、UINavigationBar属性" class="headerlink" title="3、UINavigationBar属性"></a>3、UINavigationBar属性</h4><ul>
<li><p>导航栏颜色</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *barTintColor</div></pre></td></tr></table></figure>
</li>
<li><p>导航栏渲染色</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *tintColor;</div></pre></td></tr></table></figure>
</li>
<li><p>导航栏背景图片</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBackgroundImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)backgroundImage forBarPosition:(<span class="built_in">UIBarPosition</span>)barPosition barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics  <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line">	</div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)backgroundImageForBarPosition:(<span class="built_in">UIBarPosition</span>)barPosition barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>标题属性</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *titleTextAttributes</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4、修改状态栏颜色"><a href="#4、修改状态栏颜色" class="headerlink" title="4、修改状态栏颜色"></a>4、修改状态栏颜色</h4><h6 id="创建一个高20的假状态栏背景"><a href="#创建一个高20的假状态栏背景" class="headerlink" title="创建一个高20的假状态栏背景"></a>创建一个高20的假状态栏背景</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *statusBarView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-20</span>, screenWidth, <span class="number">20</span>)];</div><div class="line">statusBarView.backgroundColor=[<span class="built_in">UIColor</span> blackColor];</div></pre></td></tr></table></figure>
<h6 id="添加到导航栏上"><a href="#添加到导航栏上" class="headerlink" title="添加到导航栏上"></a>添加到导航栏上</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.navigationController.navigationBar addSubview:statusBarView];</div></pre></td></tr></table></figure>
<h6 id="设置导航栏的背景图片"><a href="#设置导航栏的背景图片" class="headerlink" title="设置导航栏的背景图片"></a>设置导航栏的背景图片</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.navigationController.navigationBarsetBackgroundImage:[<span class="built_in">UIImageimageNamed</span>:<span class="string">@"bg.jpg"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</div></pre></td></tr></table></figure>
<h2 id="二、Segue"><a href="#二、Segue" class="headerlink" title="二、Segue"></a>二、Segue</h2><h4 id="1、什么是Segue"><a href="#1、什么是Segue" class="headerlink" title="1、什么是Segue"></a>1、什么是Segue</h4><ul>
<li>Storyboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）</li>
</ul>
<h4 id="2、Segue的属性"><a href="#2、Segue的属性" class="headerlink" title="2、Segue的属性"></a>2、Segue的属性</h4><h6 id="每一个Segue对象，都有3个属性"><a href="#每一个Segue对象，都有3个属性" class="headerlink" title="每一个Segue对象，都有3个属性"></a>每一个Segue对象，都有3个属性</h6><ul>
<li><p>唯一标识    </p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *identifier;</div></pre></td></tr></table></figure>
</li>
<li><p>来源控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> sourceViewController;</div></pre></td></tr></table></figure>
</li>
<li><p>目标控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> destinationViewController;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3、Segue的类型"><a href="#3、Segue的类型" class="headerlink" title="3、Segue的类型"></a>3、Segue的类型</h4><h6 id="根据Segue的执行（跳转）时刻，Segue可以分为2大类型"><a href="#根据Segue的执行（跳转）时刻，Segue可以分为2大类型" class="headerlink" title="根据Segue的执行（跳转）时刻，Segue可以分为2大类型"></a>根据Segue的执行（跳转）时刻，Segue可以分为2大类型</h6><ul>
<li><p>自动型：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转</p>
<ul>
<li><p>按住Control键，直接从控件拖线到目标控制器</p>
<p>  <strong>注：如果点击某个控件，不需要做任何判断，直接跳转到下一个界面，建议使用“自动型Segue”</strong> </p>
</li>
</ul>
</li>
<li>手动型：需要通过写代码手动执行Segue，才能完成界面跳转<ul>
<li>按住Control键，从来源控制器拖线到目标控制器</li>
<li>手动型的Segue需要设置一个标识（如右图）</li>
<li>在需要的时刻，由来源控制器执行perform方法调用对应的Segue</li>
<li>[self performSegueWithIdentifier:@”login2contacts” sender:nil];<ul>
<li>如果点击某个控件，需要做一些处理之后才跳转到下一个界面，建议使用“手动型Segue”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、performSegueWithIdentifier-sender"><a href="#4、performSegueWithIdentifier-sender" class="headerlink" title="4、performSegueWithIdentifier:sender:"></a>4、performSegueWithIdentifier:sender:</h4><ul>
<li><p>1、利用performSegueWithIdentifier:方法可以执行某个Segue，跳转界面</p>
<ul>
<li>完整执行过程如下：  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"login2contacts"</span> sender:<span class="literal">nil</span>];</div><div class="line"><span class="keyword">self</span>是来源控制器</div><div class="line">根据identifier去storyboard中找到对应的线，新建<span class="built_in">UIStoryboardSegue</span>对象</div><div class="line">设置Segue对象的sourceViewController（来源控制器）</div><div class="line">新建并且设置Segue对象的destinationViewController（目标控制器）</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2、调用sourceViewController的下面方法，做跳转前的准备工作并传入创建好的Segue对象</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender;</div></pre></td></tr></table></figure>
<p><strong>提示：sender是调用performSegueWithIdentifier:sender:方法时传入的对象</strong></p>
</li>
<li>3、调用Segue对象的- (void)perform;方法开始执行界面跳转操作<ul>
<li>如果segue的style是push<ul>
<li>取得sourceViewController所在的UINavigationController</li>
<li>调用UINavigationController的push方法将destinationViewController压入栈中，完成跳转</li>
</ul>
</li>
<li>如果segue的style是modal<ul>
<li>调用sourceViewController的presentViewController方法将destinationViewController展示出来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、Modal"><a href="#三、Modal" class="headerlink" title="三、Modal"></a>三、Modal</h2><ul>
<li>除了push之外，还有另外一种控制器的切换方式，那就是Modal</li>
<li>任何控制器都能通过Modal的形式展示出来</li>
<li>Modal的默认效果：新控制器从屏幕的最底部往上钻，直到盖住之前的控制器为止</li>
<li><p>以Modal的形式展示控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion</div></pre></td></tr></table></figure>
</li>
<li><p>关闭当初Modal出来的控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dismissViewControllerAnimated: (<span class="built_in">BOOL</span>)flag completion: (<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>原则：谁Modal，谁dismiss</strong></p>
<h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h2><h4 id="1、统一设置导航栏样式"><a href="#1、统一设置导航栏样式" class="headerlink" title="1、统一设置导航栏样式"></a>1、统一设置导航栏样式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 当导航栏用在BSNavViewController中, appearance设置才会生效</span></div><div class="line">    <span class="comment">//    UINavigationBar *bar = [UINavigationBar appearanceWhenContainedIn:[self class], nil];</span></div><div class="line">    <span class="comment">// 设置导航栏背景色和标题</span></div><div class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearance];</div><div class="line">    [bar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbarBackgroundWhite"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</div><div class="line">    [bar setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">20</span>]&#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置导航栏按钮内容格式</span></div><div class="line">    <span class="built_in">UIBarButtonItem</span> *item = [<span class="built_in">UIBarButtonItem</span> appearance];</div><div class="line">    <span class="comment">// UIControlStateNormal</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *attrs = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    attrs[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>];</div><div class="line">    attrs[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">    [item setTitleTextAttributes:attrs forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//UIControlStateDisabled</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *disabledAttrs = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    disabledAttrs[<span class="built_in">NSFontAttributeName</span>] = attrs[<span class="built_in">NSFontAttributeName</span>];</div><div class="line">    disabledAttrs[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    [item setTitleTextAttributes:disabledAttrs forState:<span class="built_in">UIControlStateDisabled</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、拦截导航栏push方法统一设置子控制器导航栏样式"><a href="#2、拦截导航栏push方法统一设置子控制器导航栏样式" class="headerlink" title="2、拦截导航栏push方法统一设置子控制器导航栏样式"></a>2、拦截导航栏push方法统一设置子控制器导航栏样式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="comment">//判断当前是否push到子控制器(当super写在前面时，count &gt; 1,但此时外界无法修改，因为每当外界修改完时，下面的代码又重新设置了)</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.childViewControllers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//设置子控制器的返回键</span></div><div class="line">        viewController.navigationItem.leftBarButtonItem = [<span class="built_in">UIBarButtonItem</span> itemWithTitle:<span class="string">@"返回"</span> image:<span class="string">@"navigationButtonReturn"</span> highImage:<span class="string">@"navigationButtonReturnClick"</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pop)];</div><div class="line">        <span class="comment">//将按钮往左边偏移(设置button的button.imageEdgeInsets和titleEdgeInsets)</span></div><div class="line">        viewController.hidesBottomBarWhenPushed = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/GCD:RunLoop/" itemprop="url">
                  GCD/RunLoop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T10:31:23+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络与多线程/" itemprop="url" rel="index">
                    <span itemprop="name">网络与多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、GCD"><a href="#一、GCD" class="headerlink" title="一、GCD"></a>一、GCD</h2><h4 id="1、GCD简介"><a href="#1、GCD简介" class="headerlink" title="1、GCD简介"></a>1、GCD简介</h4><h6 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h6><ul>
<li>全称是Grand Central Dispatch</li>
<li>纯C语言，提供了非常多强大的函数</li>
</ul>
<h6 id="GCD的优势"><a href="#GCD的优势" class="headerlink" title="GCD的优势"></a>GCD的优势</h6><ul>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<h4 id="2、任务和队列"><a href="#2、任务和队列" class="headerlink" title="2、任务和队列"></a>2、任务和队列</h4><h6 id="GCD中有2个核心概念"><a href="#GCD中有2个核心概念" class="headerlink" title="GCD中有2个核心概念"></a>GCD中有2个核心概念</h6><ul>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务</li>
</ul>
<h6 id="GCD的使用就2个步骤"><a href="#GCD的使用就2个步骤" class="headerlink" title="GCD的使用就2个步骤"></a>GCD的使用就2个步骤</h6><ul>
<li>定制任务:确定想做的事情</li>
<li>将任务添加到队列中:指定运行方式<ul>
<li>GCD会自动将队列中的任务取出，放到对应的线程中执行</li>
<li>任务的取出遵循队列的FIFO原则：先进先出，后进后出</li>
</ul>
</li>
</ul>
<h6 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h6><ul>
<li><p>并发队列（Concurrent Dispatch Queue）</p>
<pre><code>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）
</code></pre><p>并发功能只有在异步（dispatch_async）函数下才有</p>
</li>
<li><p>串行队列（Serial Dispatch Queue）</p>
<pre><code>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务
</code></pre></li>
<li><p>主队列</p>
<pre><code>特殊的串行队列，代表主线程
</code></pre></li>
</ul>
<h6 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h6><p><strong>GCD中有2个用来执行任务的函数</strong></p>
<ul>
<li><p>同步的方式执行任务</p>
<pre><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
</code></pre></li>
<li>异步的方式执行任务  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3、容易混淆的术语"><a href="#3、容易混淆的术语" class="headerlink" title="3、容易混淆的术语"></a>3、容易混淆的术语</h4><p><strong>有4个术语比较容易混淆：同步、异步、并发、串行</strong></p>
<h6 id="同步和异步决定了要不要开启新的线程"><a href="#同步和异步决定了要不要开启新的线程" class="headerlink" title="同步和异步决定了要不要开启新的线程"></a>同步和异步决定了要不要开启新的线程</h6><ul>
<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>
<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>
</ul>
<h6 id="并发和串行决定了任务的执行方式"><a href="#并发和串行决定了任务的执行方式" class="headerlink" title="并发和串行决定了任务的执行方式"></a>并发和串行决定了任务的执行方式</h6><ul>
<li>并发：多个任务并发（同时）执行</li>
<li>串行：一个任务执行完毕后，再执行下一个任务</li>
</ul>
<h4 id="4、串行队列"><a href="#4、串行队列" class="headerlink" title="4、串行队列"></a>4、串行队列</h4><ul>
<li>以先进先出的方式，顺序调度队列中的任务执行</li>
<li>无论队列中所指定的执行任务函数是同步还是异步，都会等待前一个任务执行完成后，再调度后面的任务</li>
</ul>
<h6 id="串行队列的执行"><a href="#串行队列的执行" class="headerlink" title="串行队列的执行"></a>串行队列的执行</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">串行队列，同步执行</div><div class="line">不开线程，同步执行(在当前线程执行)</div><div class="line"><span class="meta">#define DISPATCH_QUEUE_SERIAL NULL</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"test"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">//同步执行</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@ -- %d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">串行队列，异步执行</div><div class="line">开一个线程，顺序执行</div><div class="line">只有一个线程，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务</div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"test"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="comment">//异步执行</span></div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ -- %d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="5、并发-并行-队列"><a href="#5、并发-并行-队列" class="headerlink" title="5、并发(并行)队列"></a>5、并发(并行)队列</h4><ul>
<li>以先进先出的方式，并发调度队列中的任务执行</li>
<li>如果当前调度的任务是同步执行的，会等待任务执行完成后，再调度后续的任务</li>
<li>如果当前调度的任务是异步执行的，同时底层线程池有可用的线程资源，会再新的线程调度后续任务的执行</li>
</ul>
<h6 id="并行队列的执行"><a href="#并行队列的执行" class="headerlink" title="并行队列的执行"></a>并行队列的执行</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">并行队列，异步执行</div><div class="line">开多个线程，异步执行</div><div class="line">开多个线程，异步执行，每次开启多少个线程是不固定的(线程数，不由我们控制)，线程数是由gcd来决定的</div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"test"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="comment">//异步执行</span></div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ -- %d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">并行队列，同步执行</div><div class="line">不开线程，顺序执行 ,与串行队列同步执行一样</div></pre></td></tr></table></figure>
<h4 id="6、主队列"><a href="#6、主队列" class="headerlink" title="6、主队列"></a>6、主队列</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">主队列，异步任务</div><div class="line">不开线程，同步执行</div><div class="line">主队列特点：如果主线程正在执行代码暂时不调度任务，等主线程执行结束后在执行任务</div><div class="line">主队列又叫 全局串行队列</div><div class="line"></div><div class="line">主队列，同步执行</div><div class="line">程序执行不出来（死锁）</div><div class="line">主队列：如果主线程正在执行代码，就不调度任务</div><div class="line">同步执行：如果第一个任务没有执行，就继续等待第一个任务执行完成，再执行下一个任务此时互相等待，程序无法往下执行（死锁）</div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ -- %d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p><strong>注：主队列同步执行死锁</strong></p>
<h4 id="7、线程间通信示例"><a href="#7、线程间通信示例" class="headerlink" title="7、线程间通信示例"></a>7、线程间通信示例</h4><h6 id="从子线程回到主线程"><a href="#从子线程回到主线程" class="headerlink" title="从子线程回到主线程"></a>从子线程回到主线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(</div><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行耗时的异步操作...</span></div><div class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">// 回到主线程，执行UI刷新操作</span></div><div class="line">        &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="8、延时执行"><a href="#8、延时执行" class="headerlink" title="8、延时执行"></a>8、延时执行</h4><p><strong>iOS常见的延时执行有2种方式</strong></p>
<h6 id="调用NSObject的方法"><a href="#调用NSObject的方法" class="headerlink" title="调用NSObject的方法"></a>调用NSObject的方法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</div></pre></td></tr></table></figure>
<h6 id="使用GCD函数"><a href="#使用GCD函数" class="headerlink" title="使用GCD函数"></a>使用GCD函数</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 2秒后异步执行这里的代码...</span></div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<h4 id="9、队列组"><a href="#9、队列组" class="headerlink" title="9、队列组"></a>9、队列组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">有这么<span class="number">1</span>种需求</div><div class="line">首先：分别异步执行<span class="number">2</span>个耗时的操作</div><div class="line">其次：等<span class="number">2</span>个异步操作都执行完毕后，再回到主线程执行操作</div><div class="line"></div><div class="line">如果想要快速高效地实现上述需求，可以考虑用队列组</div><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="10、单例模式"><a href="#10、单例模式" class="headerlink" title="10、单例模式"></a>10、单例模式</h4><h6 id="单例模式的作用"><a href="#单例模式的作用" class="headerlink" title="单例模式的作用"></a>单例模式的作用</h6><ul>
<li>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数，并节约系统资源<h6 id="单例模式的使用场合"><a href="#单例模式的使用场合" class="headerlink" title="单例模式的使用场合"></a>单例模式的使用场合</h6></li>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line"><span class="comment">//要初始化的代码</span></div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、RunLoop"><a href="#二、RunLoop" class="headerlink" title="二、RunLoop"></a>二、RunLoop</h2><h4 id="1、什么是RunLoop"><a href="#1、什么是RunLoop" class="headerlink" title="1、什么是RunLoop?"></a>1、什么是RunLoop?</h4><ul>
<li>RunLoop就是消息循环,每一个线程内部都有一个消息循环。</li>
<li>只有主线程的消息循环默认开启,子线程的消息循环默认不开启。</li>
</ul>
<h4 id="2、RunLoop的目的"><a href="#2、RunLoop的目的" class="headerlink" title="2、RunLoop的目的"></a>2、RunLoop的目的</h4><ul>
<li>hn保证程序不退出 。</li>
<li>负责处理输入事件。</li>
<li>如果没有事件发生,会让程序进入休眠状态  。</li>
</ul>
<h4 id="3、如何使用"><a href="#3、如何使用" class="headerlink" title="3、如何使用"></a>3、如何使用</h4><h6 id="添加消息到循环中"><a href="#添加消息到循环中" class="headerlink" title="添加消息到循环中"></a>添加消息到循环中</h6><ul>
<li>（1）创建输入源。(以NSTimer为例)</li>
<li>（2）指定该事件（源）在循环中运行的模式，并加入循环。  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">--- [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(demo2) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">---[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h6><ol>
<li>创建消息</li>
<li>把消息放入循环，并指定消息运行的模式</li>
<li>在与循环的模式匹配的时候，消息运行</li>
</ol>
<h4 id="4、循环常用模式"><a href="#4、循环常用模式" class="headerlink" title="4、循环常用模式"></a>4、循环常用模式</h4><ul>
<li>NSDefaultRunLoopMode–默认模式</li>
<li>NSRunLoopCommonModes–普通模式</li>
</ul>
<h4 id="5、子线程中的消息循环"><a href="#5、子线程中的消息循环" class="headerlink" title="5、子线程中的消息循环"></a>5、子线程中的消息循环</h4><ul>
<li>特点：子线程默认不开启消息循环,主线程默认开启消息循环。</li>
<li>手动开启注意   <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">执行完[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];后面的代码不会执行,也关不了循环。</div><div class="line">可用[[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">5</span>]];</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/UIDynamic（物理引擎）/" itemprop="url">
                  UIDynamic（物理引擎）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T10:31:23+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/提高篇/" itemprop="url" rel="index">
                    <span itemprop="name">提高篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h4 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h4><p>a. 谁要进行物理仿真?(要谁做)</p>
<pre><code>* 物理仿真元素(Dynamic Item)
* 是任何遵守了UIDynamicItem协议的对象
</code></pre><p>b. 执行怎样的物理仿真效果?怎样的动画效果?(做什么动画)</p>
<pre><code>* 物理仿真行为(Dynamic Behavior) 
* 仿真行为,是动力学行为的父类,基本的动力学行为类
UIGravityBehavior、UICollisionBehavior、UIAttachmentBehavior、UISnapBehavi or、UIPushBehavior以及UIDynamicItemBehavior均继承自该父类,可以组合使用
</code></pre><p>c. 让物理仿真元素执行具体的物理仿真行为(开始做) </p>
<pre><code>* 物理仿真器(Dynamic Animator)
* 为动力学元素提供物理学相关的能力及动画,同时为这些元素提供相关的上 
* 下文,是动力学元素与底层iOS物理引擎之间的中介,将Behavior对象添加到 Animator即可实现动力仿真
</code></pre><p>d. 注意不是任何对象都可以做物理仿真效果 </p>
<pre><code>* 物理仿真元素要素:
* 任何遵守了UIDynamicItem协议的对象 UIView默认已经遵守了    * UIDynamicItem协议,因此任何UI控件都能做物理仿真     * UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议
</code></pre><p><strong>仿真器使用时必须设置一个strong属性使其不会立即销毁</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIDynamicAnimator</span> *animator;</div><div class="line">```	</div><div class="line"><span class="meta">#### 2、使用步骤</span></div><div class="line">a. 创建一个<span class="built_in">UIDynamicAnimator</span>对象b. 创建行为对象(<span class="built_in">UIDynamicBehavior</span>)c. 将要执行动画的对象添加到<span class="built_in">UIDynamicBehavior</span>中一般会将 <span class="built_in">UIView</span> 添加到行为对象中 <span class="built_in">UIView</span> 遵守了<span class="built_in">UIDynamicItem</span>协议</div><div class="line"></div><div class="line"><span class="meta">## 二、物理仿真行为</span></div><div class="line"><span class="meta">#### 1、重力行为(Gravity)</span></div><div class="line"><span class="meta">###### 1、重力行为用于给动力学元素指定一个重力向量</span></div><div class="line"><span class="meta">###### 2、代码示例</span></div><div class="line">```objc</div><div class="line"><span class="comment">//1 创建物理仿真器</span><span class="built_in">UIDynamicAnimator</span> *animator = [[<span class="built_in">UIDynamicAnimator</span> alloc]initWithReferenceView:<span class="keyword">self</span>.redView];<span class="keyword">self</span>.animator = animator;<span class="comment">//2 创建重力行为(物理行为)</span><span class="built_in">UIGravityBehavior</span> *behavior = [[<span class="built_in">UIGravityBehavior</span> alloc]initWithItems:@[<span class="keyword">self</span>.redView]]; <span class="comment">//量级(用来控制加速度,1.0代表加速度是1000 points</span>/second2) behavior.magnitude = <span class="number">0.2</span>; <span class="comment">//方向</span><span class="comment">//</span>behavior.gravityDirection = <span class="built_in">CGVectorMake</span>(<span class="number">1</span>, <span class="number">1</span>);behavior.angle = <span class="number">0</span>;<span class="comment">//3 把物理行为添加到物理仿真器中 开始动画</span>[animator addBehavior:behavior];</div></pre></td></tr></table></figure></p>
<h4 id="2、碰撞行为-Collision"><a href="#2、碰撞行为-Collision" class="headerlink" title="2、碰撞行为(Collision)"></a>2、碰撞行为(Collision)</h4><h6 id="1、相关属性"><a href="#1、相关属性" class="headerlink" title="1、相关属性"></a>1、相关属性</h6><p>translatesReferenceBoundsIntoBoundary</p>
<pre><code class="objc">translatesReferenceBoundsIntoBoundary设置为<span class="literal">YES</span>而不是明确的添加边界的坐标。这样会使这
个边界使用 <span class="built_in">UIDynamicAnimator</span> 提供的参考系的边界。
</code></pre>
<p>collisionMode</p>
<pre><code class="objc"><span class="built_in">UICollisionBehaviorModeItems</span> 碰到元素碰撞,边界不碰撞 <span class="built_in">UICollisionBehaviorModeBoundaries</span> 碰到边界碰撞,元素不碰撞 <span class="built_in">UICollisionBehaviorModeEverything</span> 默认,碰到边界或元素会发生碰撞
&lt;!--￼<span class="number">1</span>--&gt;

<span class="meta">###### 3、碰撞行为-其它</span>
<span class="number">1.</span> 两种自定义边界的方式,设置直线 
    a. 添加边界,设置两个点
    ```objc
    [collision addBoundaryWithIdentifier:<span class="string">@"b1"</span> fromPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">200</span>) toPoint:<span class="built_in">CGPointMake</span>(<span class="number">180</span>, <span class="number">250</span>)];
</code></pre>
<pre><code>b. 使用路径的方式
```objc
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(0, 200)];
[path addLineToPoint:CGPointMake(180, 250)];
[collision addBoundaryWithIdentifier:@&quot;b1&quot; forPath:path];
```
</code></pre><ol>
<li><p>自定义边界,设置矩形的边界</p>
<pre><code class="objc"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">180</span>, <span class="number">20</span>)]; [collision addBoundaryWithIdentifier:<span class="string">@"b2"</span> forPath:path];
</code></pre>
</li>
<li><p>碰撞过程中监听frame的变化 </p>
<pre><code class="objc">[collision setAction:^{
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.redView.frame)); }];
</code></pre>
</li>
<li>碰撞行为的弹力系数(0-1之间)<pre><code class="objc"><span class="built_in">UIDynamicItemBehavior</span> *item = [[<span class="built_in">UIDynamicItemBehavior</span> alloc] initWithItems: @[<span class="keyword">self</span>.redView]];
item.elasticity = <span class="number">1</span>;
</code></pre>
添加到物理仿真器中<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.animator addBehavior:item];</div><div class="line">```<span class="number">5.</span> 设置碰撞行为的代理,碰撞到边界以后改变物体的状态</div><div class="line">```objc- (<span class="keyword">void</span>)collisionBehavior:(<span class="built_in">UICollisionBehavior</span> *)behavior beganContactForItem:(<span class="keyword">id</span>&lt;<span class="built_in">UIDynamicItem</span>&gt;)item withBoundaryIdentifier:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)identifier atPoint:(<span class="built_in">CGPoint</span>)p &#123;<span class="comment">//开始的碰撞物体</span><span class="built_in">UIView</span> *view = (<span class="built_in">UIView</span> *)item;<span class="comment">//边界的id</span><span class="built_in">NSString</span> *strId = (<span class="built_in">NSString</span> *)identifier; <span class="comment">//当碰撞到黄色边界以后改变当前物体的颜色 if ([strId isEqualToString:@"b2"]) &#123;</span>[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^&#123; view.backgroundColor = [<span class="built_in">UIColor</span> blackColor];&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;view.backgroundColor = [<span class="built_in">UIColor</span> redColor]; &#125;];&#125; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3、捕捉行为-Snap"><a href="#3、捕捉行为-Snap" class="headerlink" title="3、捕捉行为(Snap)"></a>3、捕捉行为(Snap)</h4><h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1 物理仿真器</span><span class="keyword">self</span>.animator = [[<span class="built_in">UIDynamicAnimator</span> alloc] initWithReferenceView:<span class="keyword">self</span>.view];<span class="comment">//2 创建捕捉行为</span><span class="built_in">UISnapBehavior</span> *snap = [[<span class="built_in">UISnapBehavior</span> alloc] initWithItem:<span class="keyword">self</span>.redView snapToPoint:location]; <span class="comment">//阻尼,减幅,衰减 取值(0-1)</span>snap.damping = <span class="number">0</span>;<span class="comment">//3 把行为添加到物理仿真器</span>[<span class="keyword">self</span>.animator addBehavior:snap];</div></pre></td></tr></table></figure>
<h4 id="4、附着行为-Attachment"><a href="#4、附着行为-Attachment" class="headerlink" title="4、附着行为(Attachment)"></a>4、附着行为(Attachment)</h4><p><strong>附着行为描述一个视图与一个锚点或者另一个视图相连接的情况附着 行为描述的是两点之间的连接情况,可以模拟刚性或者弹性连接在多 个物体间设定多个UIAttachmentBehavior,可以模拟多物体连接</strong></p>
<h6 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h6><ul>
<li>attachedBehaviorType:连接类型(连接到锚点或视图) items:连接视图数组</li>
<li>anchorPoint:连接锚点</li>
<li>length:距离连接锚点的距离 只要设置了以下两个属性,即为弹性连接 * damping:振幅大小</li>
<li>frequency:振动频率</li>
</ul>
<h6 id="2、示例代码"><a href="#2、示例代码" class="headerlink" title="2、示例代码"></a>2、示例代码</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1 物理仿真器</span><span class="keyword">self</span>.animator = [[<span class="built_in">UIDynamicAnimator</span> alloc]initWithReferenceView:<span class="keyword">self</span>.view];<span class="comment">//2 重力行为</span><span class="built_in">UIGravityBehavior</span> *gravity = [[<span class="built_in">UIGravityBehavior</span> alloc] initWithItems:@[<span class="keyword">self</span>.redView]]; [gravity setAction:^&#123;view.startPoint = <span class="keyword">self</span>.redView.center;view.endPoint = point; &#125;];<span class="comment">//2.1 添加附着行为</span><span class="built_in">UIAttachmentBehavior</span> *attachment = [[<span class="built_in">UIAttachmentBehavior</span> alloc] initWithItem:<span class="keyword">self</span>.redView attachedToAnchor:point];<span class="comment">//弹性行为</span>attachment.frequency = <span class="number">0.5</span>; attachment.damping = <span class="number">0.5</span>;<span class="comment">//3 把行为添加到仿真器</span>[<span class="keyword">self</span>.animator addBehavior:gravity]; [<span class="keyword">self</span>.animator addBehavior:attachment];</div></pre></td></tr></table></figure>
<h4 id="5、推动行为-Push"><a href="#5、推动行为-Push" class="headerlink" title="5、推动行为(Push)"></a>5、推动行为(Push)</h4><p><strong>推行为可以为一个视图施加一个作用力,该力可以是持续的,也可以是一次性的可以设置力的大小,方向和作用点等信息</strong></p>
<h6 id="1、属性-1"><a href="#1、属性-1" class="headerlink" title="1、属性"></a>1、属性</h6><ul>
<li>mode:推动类型(一次性或是持续推) </li>
<li>angle:推动角度</li>
<li>magnitude:推动力量</li>
</ul>
<h6 id="2、示例代码-1"><a href="#2、示例代码-1" class="headerlink" title="2、示例代码"></a>2、示例代码</h6><pre><code class="objc"><span class="comment">//1 物理仿真器</span>
<span class="keyword">self</span>.animator = [[<span class="built_in">UIDynamicAnimator</span> alloc] initWithReferenceView:<span class="keyword">self</span>.view]; <span class="comment">//2 一次性推动行为(持续性推动行为)</span>
<span class="built_in">UIPushBehavior</span> *push = [[<span class="built_in">UIPushBehavior</span> alloc] initWithItems:@[<span class="keyword">self</span>.redView]
mode:<span class="built_in">UIPushBehaviorModeContinuous</span>];
<span class="comment">//</span>
<span class="comment">//设置推动的方向和推力的大小 push.angle = M_PI_2; push.magnitude = 1; //设置向量</span>
push.pushDirection = <span class="built_in">CGVectorMake</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">//3 把推动行为添加都物理仿真器</span>
[<span class="keyword">self</span>.animator addBehavior:push];
</code></pre>
<h4 id="6、UIDynamicItemBehavior"><a href="#6、UIDynamicItemBehavior" class="headerlink" title="6、UIDynamicItemBehavior"></a>6、UIDynamicItemBehavior</h4><p><strong>UIDynamicItemBehavior:元素行为</strong></p>
<h6 id="1、属性-2"><a href="#1、属性-2" class="headerlink" title="1、属性"></a>1、属性</h6><ul>
<li>DynamicItem是一个辅助的行为,用来设置运动学元素参与物理仿真过程中的参数,如:弹 性系数、摩擦系数、密度、阻力、角阻力以及是否允许旋转等</li>
<li>elasticity(弹性系数):决定了碰撞的弹性程度,比如碰撞时物体的弹性 * friction(摩擦系数) :决定了沿接触面滑动时的摩擦力大小</li>
<li>density(密度): 跟size结合使用,计算物体的总质量。质量越大,物体加速或减速就越 困难</li>
<li>resistance(阻力):决定线性移动的阻力大小,与摩擦系数不同,摩擦系数只作用于滑动 运动</li>
<li>angularResistance(角阻力) :决定旋转运动时的阻力大小</li>
<li>allowsRotation(允许旋转):这个属性很有意思,它在真实的物理世界没有对应的模型。 设置这个属性为 NO 物体就完全不会转动,而无论施加多大的转动力</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/04/NSDictionary:NSMutableDictionary的介绍/" itemprop="url">
                  NSDictionary/NSMutableDictionary的介绍及使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-04T10:32:18+08:00" content="2016-07-04">
              2016-07-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、NSDictionary的介绍及使用"><a href="#一、NSDictionary的介绍及使用" class="headerlink" title="一、NSDictionary的介绍及使用"></a>一、NSDictionary的介绍及使用</h1><h3 id="1、NSDictionary的介绍"><a href="#1、NSDictionary的介绍" class="headerlink" title="1、NSDictionary的介绍"></a>1、NSDictionary的介绍</h3><ul>
<li><strong>1、什么是NSDictionary？</strong><ul>
<li>NSDictionary翻译过来叫做”字典”</li>
<li>日常生活中, “字典”的作用:通过一个拼音或者汉字,就能找到对应的详细解释。</li>
</ul>
</li>
<li><p><strong>2、NSDictionary的作用:</strong></p>
<ul>
<li>类似通过一个key,就能找到对应的value。</li>
<li>NSDictionary是不可变的,一旦初始化完毕,里面的内容就无法修改。</li>
</ul>
</li>
<li><p><strong>3、NSDictionary的创建</strong></p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)dictionary;</div><div class="line">+ (<span class="keyword">instancetype</span>)dictionaryWithObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt;)key;</div><div class="line">+ (<span class="keyword">instancetype</span>)dictionaryWithObjectsAndKeys:(<span class="keyword">id</span>)firstObject, ...;</div><div class="line">+ (<span class="keyword">id</span>)dictionaryWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</div><div class="line">+ (<span class="keyword">id</span>)dictionaryWithContentsOfURL:(<span class="built_in">NSURL</span> *)url;</div></pre></td></tr></table></figure>
</li>
<li><p>4、NSDictionary的常见使用</p>
<ul>
<li><p>返回字典的键值对数目</p>
<pre><code>- (NSUInteger)count;
</code></pre></li>
<li><p>根据key取出value</p>
<pre><code>- (id)objectForKey:(id)aKey;
</code></pre></li>
<li><p>取出字典中所有的Key/Value</p>
<pre><code>@property (readonly, copy) NSArray&lt;KeyType&gt; *allKeys;
@property (readonly, copy) NSArray&lt;ObjectType&gt; *allValues;
</code></pre></li>
</ul>
</li>
<li><p>5、NSDictionary的遍历</p>
<ul>
<li><p>快速遍历</p>
<pre><code>for (NSString *key in dict) { }
</code></pre></li>
<li><p>block遍历</p>
<pre><code>[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { }];
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="2、NSDictionary的简写及文件操作"><a href="#2、NSDictionary的简写及文件操作" class="headerlink" title="2、NSDictionary的简写及文件操作"></a>2、NSDictionary的简写及文件操作</h3><ul>
<li><p><strong>1、NSDictionary 的简写形式</strong></p>
<ul>
<li>NSDictionary的创建</li>
<li><p>以前</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"Jack"</span>, <span class="string">@"name"</span>, <span class="string">@"男"</span>, <span class="string">@"sex"</span>, <span class="literal">nil</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>现在</p>
<pre><code>@{@&quot;name&quot;: @&quot;Jack&quot;, @&quot;sex&quot; : @&quot;男”};
</code></pre></li>
<li><p>NSDictionary获取元素</p>
</li>
<li><p>以前</p>
<pre><code>[dict objectForKey:@&quot;name”];
</code></pre></li>
<li><p>现在</p>
<pre><code>dict[@&quot;name”];
</code></pre></li>
</ul>
</li>
<li><p>2、NSDictionary 的文件操作</p>
<pre><code>- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;
</code></pre></li>
</ul>
<h1 id="二、NSMutableDictionary介绍和使用"><a href="#二、NSMutableDictionary介绍和使用" class="headerlink" title="二、NSMutableDictionary介绍和使用"></a>二、NSMutableDictionary介绍和使用</h1><ul>
<li><p>1、NSMutableDictionary 介绍</p>
</li>
<li><p>什么是NSMutableDictionary ?</p>
<ul>
<li>NSMutableDictionary是NSDictionary的子类</li>
<li>NSDictionary是不可变的,一旦初始化完毕后,它里面的内容就永远是固定的, 不能删除里面的元素, 也不能再往里面添加元素</li>
<li>NSMutableDictionary是可变的,随时可以往里面添加\更改\删除元素.</li>
</ul>
</li>
<li><p>2、NSMutableDictionary 的常用方法</p>
<ul>
<li>添加一个键值对(会把aKey之前对应的值给替换掉)<pre><code>- (void)setObject:(id)anObject forKey:(id &lt;NSCopying&gt;)aKey;
</code></pre></li>
<li>通过aKey删除对应的value<pre><code>- (void)removeObjectForKey:(id)aKey;
</code></pre></li>
<li>删除所有的键值对<pre><code>- (void)removeAllObjects;
</code></pre></li>
</ul>
</li>
<li><p>3、NSMutableDictionary 的简写</p>
<ul>
<li>设置键值对</li>
<li><p>以前</p>
<pre><code>[dict setObject:@&quot;Jack&quot; forKey:@&quot;name”];
</code></pre></li>
<li><p>现在</p>
<pre><code>dict[@&quot;name&quot;] = @&quot;Jack&quot;;
</code></pre></li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/04/UITabBarController/" itemprop="url">
                  UITabBarController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-04T10:31:23+08:00" content="2016-07-04">
              2016-07-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、UITabBarController属性-方法"><a href="#一、UITabBarController属性-方法" class="headerlink" title="一、UITabBarController属性/方法"></a>一、UITabBarController属性/方法</h2><ul>
<li><p>子控制器数组</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIViewController</span> *&gt; *viewControllers</div></pre></td></tr></table></figure>
</li>
<li><p>当前选中的子控制器</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) __kindof <span class="built_in">UIViewController</span> *selectedViewController;</div></pre></td></tr></table></figure>
</li>
<li><p>当前选中子控制器的下标</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> selectedIndex;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、UITabBar属性-方法"><a href="#二、UITabBar属性-方法" class="headerlink" title="二、UITabBar属性/方法"></a>二、UITabBar属性/方法</h2><ul>
<li><p>item数组</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">UITabBarItem</span> *&gt; *items;</div></pre></td></tr></table></figure>
</li>
<li><p>当前选中的item</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UITabBarItem</span> *selectedItem;</div></pre></td></tr></table></figure>
</li>
<li><p>UITabBar颜色</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *barTintColor</div></pre></td></tr></table></figure>
</li>
<li><p>UITabBar渲染颜色</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *tintColor   <span class="built_in">UI_APPEARANCE_SELECTOR</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用KVC自定义Tabbar"><a href="#使用KVC自定义Tabbar" class="headerlink" title="使用KVC自定义Tabbar"></a>使用KVC自定义Tabbar</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> setValue:[[BSTabBar alloc] init] forKey:<span class="string">@"tabBar"</span>];</div></pre></td></tr></table></figure>
<h2 id="三、统一设置tabbar样式"><a href="#三、统一设置tabbar样式" class="headerlink" title="三、统一设置tabbar样式"></a>三、统一设置tabbar样式</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize &#123;	</div><div class="line">    [<span class="built_in">UITabBar</span> appearance].backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    [<span class="keyword">self</span> setTitleAttributes];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//统一设置文字样式</span></div><div class="line">+ (<span class="keyword">void</span>)setTitleAttributes &#123;</div><div class="line">    <span class="built_in">UITabBarItem</span> *item = [<span class="built_in">UITabBarItem</span> appearance];</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableDictionary</span> *norDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    norDict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    norDict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableDictionary</span> *selDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    selDict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> grayColor];</div><div class="line">    selDict[<span class="built_in">NSFontAttributeName</span>] = norDict[<span class="built_in">NSFontAttributeName</span>];</div><div class="line">    </div><div class="line">    [item setTitleTextAttributes:norDict forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [item setTitleTextAttributes:selDict forState:<span class="built_in">UIControlStateSelected</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、TabBar添加控制器一般方法"><a href="#四、TabBar添加控制器一般方法" class="headerlink" title="四、TabBar添加控制器一般方法"></a>四、TabBar添加控制器一般方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addChildVc:[[BSEssenceViewController alloc] init] title:<span class="string">@"精华"</span> image:<span class="string">@"tabBar_essence_icon"</span> selectedImage:<span class="string">@"tabBar_essence_click_icon"</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addChildVc:[[BSNewViewController alloc] init] title:<span class="string">@"新帖"</span> image:<span class="string">@"tabBar_new_icon"</span> selectedImage:<span class="string">@"tabBar_new_click_icon"</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addChildVc:[[BSFriendTrendsViewController alloc] init] title:<span class="string">@"关注"</span> image:<span class="string">@"tabBar_friendTrends_icon"</span> selectedImage:<span class="string">@"tabBar_friendTrends_click_icon"</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addChildVc:[[BSMeViewController alloc] initWithStyle:<span class="built_in">UITableViewStyleGrouped</span>] title:<span class="string">@"我的"</span> image:<span class="string">@"tabBar_me_icon"</span> selectedImage:<span class="string">@"tabBar_me_click_icon"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//替换tabBar(KVC)</span></div><div class="line">    [<span class="keyword">self</span> setValue:[[BSTabBar alloc] init] forKey:<span class="string">@"tabBar"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加子控制器</span></div><div class="line">- (<span class="keyword">void</span>)addChildVc:(<span class="built_in">UIViewController</span> *)vc title:(<span class="built_in">NSString</span> *)title image:(<span class="built_in">NSString</span> *)image selectedImage:(<span class="built_in">NSString</span> *)selectedImage &#123;</div><div class="line">    BSNavViewController *nav = [[BSNavViewController alloc] initWithRootViewController:vc];</div><div class="line">    nav.tabBarItem.title = title;</div><div class="line">    nav.tabBarItem.image = [<span class="built_in">UIImage</span> imageNamed:image];</div><div class="line">    nav.tabBarItem.selectedImage = [<span class="built_in">UIImage</span> imageNamed:selectedImage];</div><div class="line">    [<span class="keyword">self</span> addChildViewController:nav];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/04/多线程概念和NSThread/" itemprop="url">
                  多线程概念和NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-04T10:31:23+08:00" content="2016-07-04">
              2016-07-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络与多线程/" itemprop="url" rel="index">
                    <span itemprop="name">网络与多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、多线程的基本概念"><a href="#一、多线程的基本概念" class="headerlink" title="一、多线程的基本概念"></a>一、多线程的基本概念</h2><h4 id="1、多线程的基本概念"><a href="#1、多线程的基本概念" class="headerlink" title="1、多线程的基本概念"></a>1、多线程的基本概念</h4><ol>
<li>同步:顺序执行</li>
<li>异步:同时运行</li>
<li>进程:正在运行的程序,一个或多个线程组成</li>
<li>线程:最基本的执行单元</li>
</ol>
<h4 id="2、特征"><a href="#2、特征" class="headerlink" title="2、特征"></a>2、特征</h4><ul>
<li>(单核CPU)同一时间,cpu只能处理1个线程,只有1个线程在执行 </li>
<li>多线程同时执行:是CPU快速的在多个线程之间的切换</li>
<li>cpu调度线程的时间足够快,就造成了多线程的“同时”执行</li>
<li>如果线程数非常多,cpu会在n个线程之间切换,消耗大量的cpu资源 </li>
<li>每个线程被调度的次数会降低,线程的执行效率降低 </li>
</ul>
<h6 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h6><ul>
<li>能<strong>适当</strong>提高程序的执行效率</li>
<li>能<strong>适当</strong>提高资源的利用率（CPU&amp;内存）</li>
<li>线程上得任务执行完后自动销毁</li>
</ul>
<h6 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h6><ul>
<li>开启线程需要占用一定的内存空间(默认情况下,每一个线程都占512KB) </li>
<li>如果开启大量的线程,会占用大量的内存空间,降低程序的性能</li>
<li>线程越多,cpu在调用线程上的开销就越大</li>
<li>程序设计更加复杂,比如线程间的通信、多线程的数据共享 </li>
<li><strong>时间成本和空间成本</strong></li>
</ul>
<h6 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h6><ul>
<li>一个程序运行后,默认会开启1个线程,称为“主线程”或“UI线程”</li>
<li>主线程一般用来 刷新UI界面 ,处理UI事件(比如:点击、滚动、拖拽等事件) </li>
<li>主线程使用注意 <ul>
<li>别将耗时的操作放到主线程中</li>
<li>耗时操作会卡住主线程,严重影响UI的流畅度,给用户一种卡的坏体验</li>
</ul>
</li>
</ul>
<h2 id="二、NSThread"><a href="#二、NSThread" class="headerlink" title="二、NSThread"></a>二、NSThread</h2><h4 id="1、创建和启动线程"><a href="#1、创建和启动线程" class="headerlink" title="1、创建和启动线程"></a>1、创建和启动线程</h4><p><strong>一个NSThread对象就代表一条线程</strong></p>
<h6 id="创建、启动线程"><a href="#创建、启动线程" class="headerlink" title="创建、启动线程"></a>创建、启动线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</div><div class="line">[thread start];</div><div class="line"><span class="comment">// 线程一启动，就会在线程thread中执行self的run方法</span></div></pre></td></tr></table></figure>
<h6 id="其他创建线程方式"><a href="#其他创建线程方式" class="headerlink" title="其他创建线程方式"></a>其他创建线程方式</h6><p>1、创建线程后自动启动线程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>2、隐式创建并启动线程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>3、上述2种创建线程方式的优缺点</p>
<pre><code>优点：简单快捷
缺点：无法对线程进行更详细的设置
</code></pre><h4 id="2、控制线程状态"><a href="#2、控制线程状态" class="headerlink" title="2、控制线程状态"></a>2、控制线程状态</h4><h6 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start;</div></pre></td></tr></table></figure>
<p>// 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</p>
<h6 id="阻塞（暂停）线程"><a href="#阻塞（暂停）线程" class="headerlink" title="阻塞（暂停）线程"></a>阻塞（暂停）线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</div><div class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</div></pre></td></tr></table></figure>
<p>// 进入阻塞状态</p>
<h6 id="强制停止线程"><a href="#强制停止线程" class="headerlink" title="强制停止线程"></a>强制停止线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)exit;</div></pre></td></tr></table></figure>
<p>// 进入死亡状态</p>
<p><strong>注意：一旦线程停止（死亡）了，就不能再次开启任务</strong></p>
<h4 id="3、常用属性方法"><a href="#3、常用属性方法" class="headerlink" title="3、常用属性方法"></a>3、常用属性方法</h4><h6 id="获得当前线程"><a href="#获得当前线程" class="headerlink" title="获得当前线程"></a>获得当前线程</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *current = [<span class="built_in">NSThread</span> currentThread];</div></pre></td></tr></table></figure>
<h6 id="线程的调度优先级"><a href="#线程的调度优先级" class="headerlink" title="线程的调度优先级"></a>线程的调度优先级</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">double</span>)threadPriority;</div></pre></td></tr></table></figure>
<p>调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高</p>
<h6 id="线程的名字"><a href="#线程的名字" class="headerlink" title="线程的名字"></a>线程的名字</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;</div><div class="line">- (<span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure>
<h6 id="主线程相关用法"><a href="#主线程相关用法" class="headerlink" title="主线程相关用法"></a>主线程相关用法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSThread</span> *)mainThread; <span class="comment">// 获得主线程</span></div><div class="line">- (<span class="built_in">BOOL</span>)isMainThread; <span class="comment">// 是否为主线程</span></div></pre></td></tr></table></figure>
<h4 id="4、多线程的安全隐患"><a href="#4、多线程的安全隐患" class="headerlink" title="4、多线程的安全隐患"></a>4、多线程的安全隐患</h4><h6 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h6><ul>
<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>
</ul>
<h4 id="5、安全隐患解决-–-互斥锁"><a href="#5、安全隐患解决-–-互斥锁" class="headerlink" title="5、安全隐患解决 – 互斥锁"></a>5、安全隐患解决 – 互斥锁</h4><h6 id="互斥锁使用格式"><a href="#互斥锁使用格式" class="headerlink" title="互斥锁使用格式"></a>互斥锁使用格式</h6><pre><code>@synchronized(锁对象) { // 需要锁定的代码  }
</code></pre><p><strong>注意：锁定1份代码只用1把锁，用多把锁是无效的</strong></p>
<h6 id="互斥锁的优缺点"><a href="#互斥锁的优缺点" class="headerlink" title="互斥锁的优缺点"></a>互斥锁的优缺点</h6><pre><code>优点：能有效防止因多线程抢夺资源造成的数据安全问题
缺点：需要消耗大量的CPU资源
</code></pre><p><strong>互斥锁的使用前提：多条线程抢夺同一块资源</strong></p>
<h6 id="相关专业术语：线程同步"><a href="#相关专业术语：线程同步" class="headerlink" title="相关专业术语：线程同步"></a>相关专业术语：线程同步</h6><pre><code>线程同步的意思是：多条线程按顺序地执行任务
互斥锁，就是使用了线程同步技术
</code></pre><h4 id="6、原子和非原子属性"><a href="#6、原子和非原子属性" class="headerlink" title="6、原子和非原子属性"></a>6、原子和非原子属性</h4><h6 id="OC在定义属性时有nonatomic和atomic两种选择"><a href="#OC在定义属性时有nonatomic和atomic两种选择" class="headerlink" title="OC在定义属性时有nonatomic和atomic两种选择"></a>OC在定义属性时有nonatomic和atomic两种选择</h6><ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>
<h4 id="7、线程间通信"><a href="#7、线程间通信" class="headerlink" title="7、线程间通信"></a>7、线程间通信</h4><h6 id="什么叫做线程间通信"><a href="#什么叫做线程间通信" class="headerlink" title="什么叫做线程间通信"></a>什么叫做线程间通信</h6><p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信</p>
<h6 id="线程间通信的体现"><a href="#线程间通信的体现" class="headerlink" title="线程间通信的体现"></a>线程间通信的体现</h6><ul>
<li>1个线程传递数据给另1个线程</li>
<li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li>
</ul>
<h6 id="线程间通信常用方法"><a href="#线程间通信常用方法" class="headerlink" title="线程间通信常用方法"></a>线程间通信常用方法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</div><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</div></pre></td></tr></table></figure>
<h4 id="8、什么时候使用自动释放池"><a href="#8、什么时候使用自动释放池" class="headerlink" title="8、什么时候使用自动释放池"></a>8、什么时候使用自动释放池</h4><p><strong>If you write a loop that creates many temporary objects.</strong><br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application. </p>
<p>循环中创建了许多临时对象，在循环里面使用自动释放池，用来减少高内存占用。</p>
<p><strong>If you spawn a secondary thread.</strong><br>You must create your own autorelease pool block as soon<br>as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.) </p>
<p>开启子线程的时候要自己创建自动释放池，否则可能会发生内存泄露</p>
<h6 id="自动释放池常见面试代码"><a href="#自动释放池常见面试代码" class="headerlink" title="自动释放池常见面试代码"></a>自动释放池常见面试代码</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; largeNumber; ++i) &#123;</div><div class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"Hello World"</span>;</div><div class="line">    str = [str stringByAppendingFormat:<span class="string">@" - %d"</span>, i];</div><div class="line">    str = [str uppercaseString];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在for循环内部加入一个自动释放池</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Lonely920" />
          <p class="site-author-name" itemprop="name">Lonely920</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lonely920</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
